
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/stefaanc/terraform-provider-hosts/api/file.go (99.6%)</option>
				
				<option value="file1">github.com/stefaanc/terraform-provider-hosts/api/hosts.go (100.0%)</option>
				
				<option value="file2">github.com/stefaanc/terraform-provider-hosts/api/record.go (100.0%)</option>
				
				<option value="file3">github.com/stefaanc/terraform-provider-hosts/api/zone.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//
// Copyright (c) 2019 Stefaan Coussement
// MIT License
//
// more info: https://github.com/stefaanc/terraform-provider-hosts
//
package api

import (
    "bufio"
    "bytes"
    "crypto/sha1"
    "errors"
    "encoding/hex"
    //"fmt"
    "io"
    "io/ioutil"
    "log"
    "os"
    "strings"
)

// -----------------------------------------------------------------------------

type File struct {
    // readOnly
    ID        int      // indexed   // read-write in a fQuery
    // read-writeOnce
    Path      string   // indexed
    // read-writeMany
    Notes     string
    // private
    id        fileID
    hostsFile *fileObject
    zones     []*zoneObject   // !!! beware of memory leaks
}

func LookupFile(fQuery *File) (f *File) <span class="cov8" title="1">{
    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return nil
    }</span>

    // make a copy without the private fields
    <span class="cov8" title="1">f = new(File)
    f.ID    = fPrivate.ID
    f.Path  = fPrivate.Path
    f.Notes = fPrivate.Notes
    // ignore computed fields

    return f</span>
}

func CreateFile(fValues *File) error <span class="cov8" title="1">{
    if fValues.Path == "" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateFile(fValues)] missing 'fValues.Path'")
    }</span>

    // lookup all indexed fields except ID
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.Path = fValues.Path

    fPrivate := lookupFile(fQuery)
    if fPrivate != nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateFile(fValues)] another file with similar properties already exists")
    }</span>

    <span class="cov8" title="1">return createFile(fValues)</span>   // fValues.ID will be ignored
}

func (f *File) Read() (file *File, err error) <span class="cov8" title="1">{
    if f.ID == 0 </span><span class="cov8" title="1">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/f.Read()] missing 'f.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.ID = f.ID

    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/f.Read()] file not found")
    }</span>

    // read file
    <span class="cov8" title="1">fPrivate, err = readFile(fPrivate)
    if err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>

    // make a copy without the private fields
    <span class="cov8" title="1">file = new(File)
    file.ID    = fPrivate.ID
    file.Path  = fPrivate.Path
    file.Notes = fPrivate.Notes
    // no computed fields

    return file, nil</span>
}

func (f *File) Update(fValues *File) error <span class="cov8" title="1">{
    if f.ID == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/f.Update(fValues)] missing 'f.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.ID = f.ID

    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/f.Update(fValues)] file not found")
    }</span>

    <span class="cov8" title="1">return updateFile(fPrivate, fValues)</span>   // fValues.ID and fValues.Path will be ignored
}

func (f *File) Delete() error <span class="cov8" title="1">{
    if f.ID == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/f.Delete(fValues)] missing 'f.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.ID = f.ID

    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/f.Delete()] file not found")
    }</span>

    <span class="cov8" title="1">return deleteFile(fPrivate)</span>
}

// -----------------------------------------------------------------------------
//
// naming guidelines:
//
// - (f *File)         the result of the public CreateFile method and LookupFile method
//                         this doesn't include the computed fields (always use a read method to get the computed fields)
//                         this doesn't include the private fields
//
//                     the result of the private createFile method and lookupFile method (hosts.go)
//                         this doesn't include the computed fields (always use a read method to get the computed fields)
//
//                     the anchor for the public Read/Update/Delete methods
//                         this must include the 'ID' field
//
//                     the input for the private readFile/updateFile/deleteFile methods
//                         this must include the private 'id' field
//
// - (fQuery *File)    the input for the public LookupFile method
//                     the input for the private lookupFile method (hosts.go)
//                         this should include at least one of the indexed fields
//
//   (fValues *File)   the input for the public CreateFile/Update methods
//                     the input for the private createFile/updateFile methods
//                         for a create method, this must include *all* writeMany and writeOnce fields
//                         for an update method, this must include *all* writeMany fields
//
// - (file *File)      the result of the public Read method
//                     the result of the private readFile method
//                         this does include all computed fields
//
// -----------------------------------------------------------------------------

func createFile(fValues *File) error <span class="cov8" title="1">{
    // create and initialize file object
    f := new(File)
    f.Path = fValues.Path
    f.Notes = fValues.Notes

    f.hostsFile = fValues.hostsFile  // requested by goScanFile()
    // f.zones                       // filled by goScanFile()

    addFile(f)   // adds f.ID and f.id

    if fValues.hostsFile == nil </span><span class="cov8" title="1">{   // if requested by CreateFile()
        // add the file to the hosts
        hostsFile := new(fileObject)
        hostsFile.file = f      // !!! beware of memory leaks
        f.hostsFile = hostsFile // !!! beware of memory leaks

        addFileObject(hostsFile)

        // read physical file, if it doesn't exist then create it
        data, err := ioutil.ReadFile(f.Path)
        if err == nil </span><span class="cov8" title="1">{
            log.Printf("[INFO][terraform-provider-hosts/api/readFile()] read physical file %d, path %q\n", f.ID, f.Path)
        }</span> else<span class="cov8" title="1"> {
            if os.IsNotExist(err) </span><span class="cov8" title="1">{
                data = []byte(nil)
                err = ioutil.WriteFile(f.Path, data, 0644)
                if err == nil </span><span class="cov8" title="1">{
                    log.Printf("[INFO][terraform-provider-hosts/api/createFile()] created physical file %d, path %q\n", f.ID, f.Path)
                }</span>
            }
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
            // restore consistent state
            removeFileObject(hostsFile)
            f.hostsFile = nil   // !!! avoid memory leaks
            removeFile(f)

            return err
        }</span>

        <span class="cov8" title="1">checksum := sha1.Sum(data)
        f.hostsFile.checksum = hex.EncodeToString(checksum[:])

        // process data
        done := goScanFile(f.hostsFile, bytes.NewReader(data))
        _ = &lt;-done</span>
   }

    <span class="cov8" title="1">log.Printf("[INFO][terraform-provider-hosts/api/createFile()] created file %d, path %q\n", f.ID, f.Path)
    return nil</span>
}

func readFile(f *File) (file *File, err error) <span class="cov8" title="1">{
    // read physical file
    data, err := ioutil.ReadFile(f.Path)
    if err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>
    <span class="cov8" title="1">log.Printf("[INFO][terraform-provider-hosts/api/readFile()] read physical file %d, path %q\n", f.ID, f.Path)

    checksum := sha1.Sum(data)
    newChecksum := hex.EncodeToString(checksum[:])

    if f.hostsFile.checksum != newChecksum </span><span class="cov8" title="1">{
        f.hostsFile.checksum = newChecksum

        // process data
        done := goScanFile(f.hostsFile, bytes.NewReader(data))
        _ = &lt;-done
    }</span>

    // no computed fields

    <span class="cov8" title="1">log.Printf("[INFO][terraform-provider-hosts/api/readFile()] read file %d, path %q\n", f.ID, f.Path)
    return f, nil</span>
}

func updateFile(f *File, fValues *File) error <span class="cov8" title="1">{
    notes   := f.Notes     // save so we can restore if needed
    oldChecksum := f.hostsFile.checksum   // save to compare old with new

    // update file
    f.Notes    = fValues.Notes

    if fValues.hostsFile == nil || f == fValues </span><span class="cov8" title="1">{   // if requested by f.Update() or if forcing a render/write
        // render file to calculate new checksum
        done := goRenderFile(f)   // updates data &amp; checksum
        _ = &lt;-done
        
        if f.hostsFile.checksum != oldChecksum </span><span class="cov8" title="1">{
            // update physical file
            err := ioutil.WriteFile(f.Path, f.hostsFile.data, 0644)
            if err != nil </span><span class="cov8" title="1">{
                // restore consistent state
                f.Notes = notes
                f.hostsFile.data     = []byte(nil)
                f.hostsFile.checksum = oldChecksum

                return err
            }</span>
            <span class="cov8" title="1">log.Printf("[INFO][terraform-provider-hosts/api/updateFile()] updated physical file %d, path %q\n", f.ID, f.Path)</span>
        }

        // don't keep rendered data in memory
        <span class="cov8" title="1">f.hostsFile.data = []byte(nil)</span>
    }

    <span class="cov8" title="1">log.Printf("[INFO][terraform-provider-hosts/api/updateFile()] updated file %d, path %q\n", f.ID, f.Path)
    return nil</span>
}

func deleteFile(f *File) error <span class="cov8" title="1">{
    // remove the zone from the file
    if f.hostsFile != nil </span><span class="cov8" title="1">{   // if requested by f.Delete()
        removeFileObject(f.hostsFile)
        oldHostsFile := f.hostsFile   // save so we can restore if needed
        f.hostsFile = nil            // !!! avoid memory leaks

        if len(f.zones) == 0 </span><span class="cov8" title="1">{
            // delete physical file
            err := os.Remove(f.Path)
            if err != nil </span><span class="cov8" title="1">{
               // restore consistent state
               f.hostsFile = oldHostsFile   // !!! beware of memory leaks
               addFileObject(f.hostsFile)

               return err
            }</span>
            <span class="cov8" title="1">log.Printf("[INFO][terraform-provider-hosts/api/deleteFile()] deleted physical file %d, path %q\n", f.ID, f.Path)</span>
        }
    }

    // save for logging
    <span class="cov8" title="1">id := f.ID
    path := f.Path

    // remove and zero file object
    removeFile(f)   // zeroes f.ID and f.id

    f.Path = ""
    f.Notes = ""

    for _, zoneObject := range f.zones </span><span class="cov8" title="1">{   // !!! avoid memory leaks
        zoneObject.zone = nil
    }</span>
    <span class="cov8" title="1">f.zones = []*zoneObject(nil)

    log.Printf("[INFO][terraform-provider-hosts/api/deleteFile()] deleted file %d, path %q\n", id, path)
    return nil</span>
}

// -----------------------------------------------------------------------------

func goRenderFile(f *File) chan bool <span class="cov8" title="1">{
    done := make(chan bool)

    go func() </span><span class="cov8" title="1">{
        defer close(done)

        // render bytes
        rendered := bytes.NewBuffer([]byte(nil))
        w := io.Writer(rendered)

        // render lines for the default external zone
        zQuery := new(Zone)
        zQuery.File = f.ID
        zQuery.Name = "external"
        z := lookupZone(zQuery)
        if z != nil </span><span class="cov8" title="1">{
            for _, line := range z.fileZone.lines </span><span class="cov8" title="1">{
                // update lines
                _, _ = io.WriteString(w, line)   // error cannot happen
                _, _ = io.WriteString(w, "\n")   // error cannot happen
            }</span>
        }

        <span class="cov8" title="1">for _, zoneObject := range f.zones </span><span class="cov8" title="1">{
            if zoneObject.zone.Name == "external" </span><span class="cov8" title="1">{
                continue</span>
            }

            <span class="cov8" title="1">for _, line := range zoneObject.lines </span><span class="cov8" title="1">{
                // update lines
                _, _ = io.WriteString(w, line)   // error cannot happen
                _, _ = io.WriteString(w, "\n")   // error cannot happen
            }</span>
        }

        // calculate checksum for the lines
        <span class="cov8" title="1">data := rendered.Bytes()
        checksum := sha1.Sum(data)

        // update zoneObject
        f.hostsFile.data = data
        f.hostsFile.checksum = hex.EncodeToString(checksum[:])

        // finish goRenderZones()
        done &lt;- true
        return</span>
    }()

    <span class="cov8" title="1">return done</span>
}

// -----------------------------------------------------------------------------

func goScanFile(hostsFile *fileObject, r io.Reader) chan bool <span class="cov8" title="1">{
    done := make(chan bool)

    go func() </span><span class="cov8" title="1">{
        defer close(done)

        f := hostsFile.file

        // keep the old slice of zoneObjects to cleanup old zones that aren't replaced
        oldZones := f.zones

        // update file with new slice of zoneObjects
        f.zones = make([]*zoneObject, 0)

        defer func() </span><span class="cov8" title="1">{
            // cleanup zones that aren't replaced
            for _, fileZone := range oldZones </span><span class="cov8" title="1">{
                z := fileZone.zone
                if z.fileZone == fileZone </span><span class="cov8" title="1">{   // if zone was deleted from the read file, fileZone was not replaced
                    // delete zone object
                    z.fileZone = nil   // !!! avoid memory leaks
                    _ = deleteZone(z)   // error cannot happen
                }</span>
            }
        }()

        // create 'external' zoneObject
        <span class="cov8" title="1">fileZone := new(zoneObject)
        addZoneObject(f, fileZone)

        lines2 := make(chan string)
        done2  := goScanZone(f, fileZone, lines2)

        // save this channel for later use
        fileZoneExternal := fileZone
        linesExternal := lines2
        doneExternal := done2

        // start scanning
        scanner := bufio.NewScanner(r)
        for scanner.Scan() </span><span class="cov8" title="1">{
            line := scanner.Text()

            // create new zoneObject when startZoneMarker
            // complete old zoneObject if not external
            if strings.HasPrefix(line, startZoneMarker) </span><span class="cov8" title="1">{
                // line is a marker for the start of new zone
                if lines2 != linesExternal </span><span class="cov8" title="1">{
                    // unexpected startZoneMarker, probably an endZoneMarker missing =&gt; silently ignore
                    log.Printf("[WARNING][terraform-provider-hosts/api/goScanFile()] unexpected start-of-zone marker - missing end-of-zone marker: \n&gt; %q", line)

                    // wait for goScanZone() of the current zone to finish
                    lines2 &lt;- endZoneMarker   // insert an endZoneMarker
                    close(lines2)
                    _ = &lt;-done2
                }</span>

                // create new zone
                <span class="cov8" title="1">fileZone = new(zoneObject)
                addZoneObject(f, fileZone)

                lines2 = make(chan string)
                done2 = goScanZone(f, fileZone, lines2)</span>
            }

            // complete old zoneObject if not external
            <span class="cov8" title="1">if strings.HasPrefix(line, endZoneMarker) </span><span class="cov8" title="1">{
                // line is a marker for the end of current zone
                if lines2 == linesExternal </span><span class="cov8" title="1">{
                    // unexpected endZoneMarker, probably a startZoneMarker missing =&gt; silently ignore
                    // all records from the zone with missing startZoneMarker will be in the external zone
                    log.Printf("[WARNING][terraform-provider-hosts/api/goScanFile()] unexpected end-of-zone marker, skipping line: \n&gt; %q", line)
                    continue</span>
                }

                // wait for goScanZone() of the current zone to finish
                <span class="cov8" title="1">fileZone.lines = append(fileZone.lines, line)
                lines2 &lt;- line
                close(lines2)
                _ = &lt;-done2

                // back to external zone
                fileZone = fileZoneExternal
                lines2 = linesExternal
                done2 = doneExternal

                continue</span>
            }

            <span class="cov8" title="1">fileZone.lines = append(fileZone.lines, line)
            lines2 &lt;- line</span>
        }
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{   // cannot happen at the moment - crash if code is modified
            // scanner error
            log.Fatal(err)
        }</span>

        <span class="cov8" title="1">if lines2 != linesExternal </span><span class="cov8" title="1">{
            // endZoneMarker missing =&gt; silently ignore
            log.Printf("[WARNING][terraform-provider-hosts/api/goScanFile()] missing end-of-zone marker")

            // wait for goScanZone() of the current zone to finish
            lines2 &lt;- endZoneMarker   // insert an endZoneMarker
            close(lines2)
            _ = &lt;-done2
        }</span>

        // wait for goScanLines() of the external zone to finish
        <span class="cov8" title="1">close(linesExternal)
        _ = &lt;-doneExternal
        if len(fileZoneExternal.lines) == 0 </span><span class="cov8" title="1">{
            removeZoneObject(f, fileZoneExternal)
        }</span>

        // finish goScanZones()
        <span class="cov8" title="1">done &lt;- true
        return</span>
    }()

    <span class="cov8" title="1">return done</span>
}

// -----------------------------------------------------------------------------

type zoneObject struct {
    lines    []string
    checksum string
    zone  *Zone   // !!! beware of memory leaks
}

func addZoneObject(f *File, z *zoneObject) <span class="cov8" title="1">{
    f.zones = append(f.zones, z)
    return
}</span>

func removeZoneObject(f *File, z *zoneObject) <span class="cov8" title="1">{
    f.zones = deleteFromSliceOfZoneObjects(f.zones, z)
    return
}</span>

func deleteFromSliceOfZoneObjects(zs []*zoneObject, z *zoneObject) []*zoneObject <span class="cov8" title="1">{
    if len(zs) == 0 </span><span class="cov8" title="1">{
        return []*zoneObject(nil)   // always return a copy
    }</span>

    <span class="cov8" title="1">newZoneObjects := make([]*zoneObject, 0, len(zs) - 1)
    for _, zoneObject := range zs </span><span class="cov8" title="1">{
        if z == zoneObject </span><span class="cov8" title="1">{
            continue</span>
        }
        <span class="cov8" title="1">newZoneObjects = append(newZoneObjects, zoneObject)</span>
    }

    <span class="cov8" title="1">return newZoneObjects</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">//
// Copyright (c) 2019 Stefaan Coussement
// MIT License
//
// more info: https://github.com/stefaanc/terraform-provider-hosts
//
package api

import (
    "sync"
)

// -----------------------------------------------------------------------------

func Init() <span class="cov8" title="1">{
    initHosts()
    return
}</span>

// -----------------------------------------------------------------------------

type anchor struct {
    files []*fileObject   // !!! beware of memory leaks

    newFileID func () fileID
    fileIndex *fileIndex

    newZoneID func () zoneID
    zoneIndex *zoneIndex

    newRecordID func () recordID
    recordIndex *recordIndex
}

var hosts *anchor

func initHosts() <span class="cov8" title="1">{
    if hosts != nil </span><span class="cov8" title="1">{
        // already initialized
        return
    }</span>

    <span class="cov8" title="1">hosts = new(anchor)

    lastFileID := fileID(0)
    hosts.newFileID = func() fileID </span><span class="cov8" title="1">{
        lastFileID += 1
        return lastFileID
    }</span>
    <span class="cov8" title="1">hosts.fileIndex = new(fileIndex)
    hosts.fileIndex.index = make(map[fileID]*File)
    hosts.fileIndex.paths = make(map[string][]*File)

    lastZoneID := zoneID(0)
    hosts.newZoneID = func() zoneID </span><span class="cov8" title="1">{
        lastZoneID += 1
        return lastZoneID
    }</span>
    <span class="cov8" title="1">hosts.zoneIndex = new(zoneIndex)
    hosts.zoneIndex.index = make(map[zoneID]*Zone)
    hosts.zoneIndex.files = make(map[fileID][]*Zone)
    hosts.zoneIndex.names = make(map[string][]*Zone)

    lastRecordID := recordID(0)
    hosts.newRecordID = func() recordID </span><span class="cov8" title="1">{
        lastRecordID += 1
        return lastRecordID
    }</span>
    <span class="cov8" title="1">hosts.recordIndex = new(recordIndex)
    hosts.recordIndex.index = make(map[recordID]*Record)
    hosts.recordIndex.zones = make(map[zoneID][]*Record)
    hosts.recordIndex.addresses = make(map[string][]*Record)
    hosts.recordIndex.names = make(map[string][]*Record)</span>
}

// -----------------------------------------------------------------------------

type fileID int

type fileIndex struct {
    sync.RWMutex
    index map[fileID]*File
    paths map[string][]*File
}

func lookupFile(fQuery *File) (f *File) <span class="cov8" title="1">{
    if fQuery.id != 0 </span><span class="cov8" title="1">{
        return fQuery
    }</span>

    <span class="cov8" title="1">fs := queryFiles(fQuery)

    if len(fs) != 1 </span><span class="cov8" title="1">{
        // if more than 1 valid file, 'lookup' cannot decide which one to return
        return nil
    }</span>

    <span class="cov8" title="1">return fs[0]</span>
}

func queryFiles(fQuery *File) (fs []*File) <span class="cov8" title="1">{
    if fQuery.ID != 0 </span><span class="cov8" title="1">{
        hosts.fileIndex.RLock()
        f := hosts.fileIndex.index[fileID(fQuery.ID)]
        hosts.fileIndex.RUnlock()

        if f == nil </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying properties
        <span class="cov8" title="1">if fQuery.Path != "" &amp;&amp; fQuery.Path != f.Path </span><span class="cov8" title="1">{
            return nil
        }</span>

        <span class="cov8" title="1">return []*File{ f }</span>
    }

    <span class="cov8" title="1">if fQuery.Path != "" </span><span class="cov8" title="1">{
        hosts.fileIndex.RLock()
        fs := hosts.fileIndex.paths[fQuery.Path]
        hosts.fileIndex.RUnlock()

        return fs
    }</span>

    <span class="cov8" title="1">return nil</span>
}

func addFile(f *File) <span class="cov8" title="1">{
    if f.id != 0 </span><span class="cov8" title="1">{
        // file already indexed
        return
    }</span>

    <span class="cov8" title="1">id := hosts.newFileID()
    path := f.Path

    hosts.fileIndex.Lock()
    hosts.fileIndex.index[id] = f
    hosts.fileIndex.paths[path] = append(hosts.fileIndex.paths[path], f)
    hosts.fileIndex.Unlock()

    f.ID = int(id)
    f.id = id

    return</span>
}

func removeFile(f *File) <span class="cov8" title="1">{
    if f.id == 0 </span><span class="cov8" title="1">{
        // file not indexed yet/anymore
        return
    }</span>

    <span class="cov8" title="1">id := f.id
    path := f.Path

    hosts.fileIndex.Lock()
    delete(hosts.fileIndex.index, id)
    hosts.fileIndex.paths[path] = deleteFromSliceOfFiles(hosts.fileIndex.paths[path], f)
    hosts.fileIndex.Unlock()

    f.ID = 0
    f.id = fileID(0)

    return</span>
}

func deleteFromSliceOfFiles(fs []*File, f *File) []*File <span class="cov8" title="1">{
    if len(fs) == 0 </span><span class="cov8" title="1">{
        return []*File(nil)   // always return a copy
    }</span>

    <span class="cov8" title="1">newFiles := make([]*File, 0, len(fs) - 1)
    for _, file := range fs </span><span class="cov8" title="1">{
        if file == f </span><span class="cov8" title="1">{
            continue</span>
        }

        <span class="cov8" title="1">newFiles = append(newFiles, file)</span>
    }

    <span class="cov8" title="1">return newFiles</span>
}

// -----------------------------------------------------------------------------

type zoneID int

type zoneIndex struct {
    sync.RWMutex
    index map[zoneID]*Zone
    files map[fileID][]*Zone
    names map[string][]*Zone
}

func lookupZone(zQuery *Zone) (z *Zone) <span class="cov8" title="1">{
    if zQuery.id != 0 </span><span class="cov8" title="1">{
        return zQuery
    }</span>

    <span class="cov8" title="1">zs := queryZones(zQuery)

    if len(zs) != 1 </span><span class="cov8" title="1">{
        // if more than 1 valid zone, 'lookup' cannot decide which one to return
        return nil
    }</span>

    <span class="cov8" title="1">return zs[0]</span>
}

func queryZones(zQuery *Zone) (zs []*Zone) <span class="cov8" title="1">{
    if zQuery.ID != 0 </span><span class="cov8" title="1">{
        hosts.zoneIndex.RLock()
        z := hosts.zoneIndex.index[zoneID(zQuery.ID)]
        hosts.zoneIndex.RUnlock()

        if z == nil </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying properties
        <span class="cov8" title="1">if zQuery.File != 0 &amp;&amp; zQuery.File != z.File </span><span class="cov8" title="1">{
            return nil
        }</span>
        <span class="cov8" title="1">if zQuery.Name != "" &amp;&amp; zQuery.Name != z.Name </span><span class="cov8" title="1">{
            return nil
        }</span>

        <span class="cov8" title="1">return []*Zone{z}</span>
    }

    <span class="cov8" title="1">if zQuery.Name != "" </span><span class="cov8" title="1">{
        hosts.zoneIndex.RLock()
        zs := hosts.zoneIndex.names[zQuery.Name]
        hosts.zoneIndex.RUnlock()
        if len(zs) == 0 </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying properties
        <span class="cov8" title="1">if zQuery.File != 0 </span><span class="cov8" title="1">{
            zsReduced := make([]*Zone, 0)
            for _, candidate := range zs </span><span class="cov8" title="1">{
                // a valid candidate has a file equal to zQuery.File
                if candidate.File == zQuery.File </span><span class="cov8" title="1">{
                    zsReduced = append(zsReduced, candidate)
                }</span>
            }
            <span class="cov8" title="1">zs = zsReduced

            if len(zs) == 0 </span><span class="cov8" title="1">{
                return nil
            }</span>
        }

        <span class="cov8" title="1">return zs</span>
    }

    <span class="cov8" title="1">if zQuery.File != 0 </span><span class="cov8" title="1">{
        hosts.zoneIndex.RLock()
        zs := hosts.zoneIndex.files[fileID(zQuery.File)]
        hosts.zoneIndex.RUnlock()

        return zs
    }</span>

    <span class="cov8" title="1">return nil</span>
}

func addZone(z *Zone) <span class="cov8" title="1">{
    if z.id != 0 </span><span class="cov8" title="1">{
        // zone already indexed
        return
    }</span>

    <span class="cov8" title="1">id := hosts.newZoneID()
    file := fileID(z.File)
    name := z.Name

    hosts.zoneIndex.Lock()
    hosts.zoneIndex.index[id] = z
    hosts.zoneIndex.files[file] = append(hosts.zoneIndex.files[file], z)
    hosts.zoneIndex.names[name] = append(hosts.zoneIndex.names[name], z)
    hosts.zoneIndex.Unlock()

    z.ID = int(id)
    z.id = id

    return</span>
}

func removeZone(z *Zone) <span class="cov8" title="1">{
    if z.id == 0 </span><span class="cov8" title="1">{
        // file not indexed yet/anymore
        return
    }</span>

    <span class="cov8" title="1">id := z.id
    file := fileID(z.File)
    name := z.Name

    hosts.zoneIndex.Lock()
    delete(hosts.zoneIndex.index, id)
    hosts.zoneIndex.files[file] = deleteFromSliceOfZones(hosts.zoneIndex.files[file], z)
    hosts.zoneIndex.names[name] = deleteFromSliceOfZones(hosts.zoneIndex.names[name], z)
    hosts.zoneIndex.Unlock()

    z.ID = 0
    z.id = zoneID(0)

    return</span>
}

func deleteFromSliceOfZones(zs []*Zone, z *Zone) []*Zone <span class="cov8" title="1">{
    if len(zs) == 0 </span><span class="cov8" title="1">{
        return []*Zone(nil)   // always return a copy
    }</span>

    <span class="cov8" title="1">newZones := make([]*Zone, 0, len(zs) - 1)
    for _, zone := range zs </span><span class="cov8" title="1">{
        if zone == z </span><span class="cov8" title="1">{
            continue</span>
        }
        <span class="cov8" title="1">newZones = append(newZones, zone)</span>
    }

    <span class="cov8" title="1">return newZones</span>
}

// -----------------------------------------------------------------------------

type recordID int

type recordIndex struct {
    sync.RWMutex
    index map[recordID]*Record
    zones map[zoneID][]*Record
    addresses map[string][]*Record
    names map[string][]*Record
}

func lookupRecord(rQuery *Record) (r *Record) <span class="cov8" title="1">{
    if rQuery.id != 0 </span><span class="cov8" title="1">{
        return rQuery
    }</span>

    <span class="cov8" title="1">rs := queryRecords(rQuery)

    if len(rs) != 1 </span><span class="cov8" title="1">{
        // if more than 1 valid record, 'lookup' cannot decide which one to return
        return nil
    }</span>

    <span class="cov8" title="1">return rs[0]</span>
}

func queryRecords(rQuery *Record) (rs []*Record) <span class="cov8" title="1">{
    if rQuery.ID != 0 </span><span class="cov8" title="1">{
        hosts.recordIndex.RLock()
        r := hosts.recordIndex.index[recordID(rQuery.ID)]
        hosts.recordIndex.RUnlock()

        if r == nil </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying properties
        <span class="cov8" title="1">if rQuery.Zone != 0 &amp;&amp; rQuery.Zone != r.Zone </span><span class="cov8" title="1">{
            return nil
        }</span>
        <span class="cov8" title="1">if rQuery.Address != "" &amp;&amp; rQuery.Address != r.Address </span><span class="cov8" title="1">{
            return nil
        }</span>
        <span class="cov8" title="1">if len(rQuery.Names) &gt; 0 </span><span class="cov8" title="1">{
            // a valid record has all names (or more) that are found in r.Names
            valid := true
            for _, n := range rQuery.Names </span><span class="cov8" title="1">{
                found := false
                for _, name := range r.Names </span><span class="cov8" title="1">{
                    if n == name </span><span class="cov8" title="1">{
                        found = true
                        break</span>
                    }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                    valid = false
                    break</span>
                }
            }
            <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{
                return nil
            }</span>
        }

        <span class="cov8" title="1">return []*Record{ r }</span>
    }

    <span class="cov8" title="1">if len(rQuery.Names) &gt; 0 </span><span class="cov8" title="1">{
        hosts.recordIndex.RLock()
        rs := hosts.recordIndex.names[rQuery.Names[0]]
        hosts.recordIndex.RUnlock()

        if len(rs) == 0 </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying names
        <span class="cov8" title="1">if len(rQuery.Names) &gt; 0 </span><span class="cov8" title="1">{
            rsReduced := make([]*Record, 0)
            for _, candidate := range rs </span><span class="cov8" title="1">{
                // a valid candidate has all names (or more) that are found in rQuery.Names
                valid := true
                for _, n := range rQuery.Names </span><span class="cov8" title="1">{
                    found := false
                    for _, name := range candidate.Names </span><span class="cov8" title="1">{
                        if n == name </span><span class="cov8" title="1">{
                            found = true
                            break</span>
                        }
                    }
                    <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        valid = false
                        break</span>
                    }
                }
                <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                    rsReduced = append(rsReduced, candidate)
                }</span>
            }
            <span class="cov8" title="1">rs = rsReduced

            if len(rs) == 0 </span><span class="cov8" title="1">{
                return nil
            }</span>
        }

        // check other identifying properties
        <span class="cov8" title="1">if rQuery.Address != "" </span><span class="cov8" title="1">{
            rsReduced := make([]*Record, 0)
            for _, candidate := range rs </span><span class="cov8" title="1">{
                // a valid candidate has an address equal to rQuery.Address
                if candidate.Address == rQuery.Address </span><span class="cov8" title="1">{
                    rsReduced = append(rsReduced, candidate)
                }</span>
            }
            <span class="cov8" title="1">rs = rsReduced

            if len(rs) == 0 </span><span class="cov8" title="1">{
                return nil
            }</span>
        }
        <span class="cov8" title="1">if rQuery.Zone != 0 </span><span class="cov8" title="1">{
            rsReduced := make([]*Record, 0)
            for _, candidate := range rs </span><span class="cov8" title="1">{
                // a valid candidate has a zone equal to rQuery.Zone
                if candidate.Zone == rQuery.Zone </span><span class="cov8" title="1">{
                    rsReduced = append(rsReduced, candidate)
                }</span>
            }
            <span class="cov8" title="1">rs = rsReduced

            if len(rs) == 0 </span><span class="cov8" title="1">{
                return nil
            }</span>
        }

        <span class="cov8" title="1">return rs</span>
    }

    <span class="cov8" title="1">if rQuery.Address != "" </span><span class="cov8" title="1">{
        hosts.recordIndex.RLock()
        rs := hosts.recordIndex.addresses[rQuery.Address]
        hosts.recordIndex.RUnlock()

        if len(rs) == 0 </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying properties
        <span class="cov8" title="1">if rQuery.Zone != 0 </span><span class="cov8" title="1">{
            rsReduced := make([]*Record, 0)
            for _, candidate := range rs </span><span class="cov8" title="1">{
                // a valid candidate has a zone equal to rQuery.Zone
                if candidate.Zone == rQuery.Zone </span><span class="cov8" title="1">{
                    rsReduced = append(rsReduced, candidate)
                }</span>
            }
            <span class="cov8" title="1">rs = rsReduced

            if len(rs) == 0 </span><span class="cov8" title="1">{
                return nil
            }</span>
        }

        <span class="cov8" title="1">return rs</span>
    }

    <span class="cov8" title="1">if rQuery.Zone != 0 </span><span class="cov8" title="1">{
        hosts.recordIndex.RLock()
        rs := hosts.recordIndex.zones[zoneID(rQuery.Zone)]
        hosts.recordIndex.RUnlock()

        return rs
    }</span>

    <span class="cov8" title="1">return nil</span>
}

func addRecord(r *Record) <span class="cov8" title="1">{
    if r.id != 0 </span><span class="cov8" title="1">{
        // record already indexed
        return
    }</span>

    <span class="cov8" title="1">id := hosts.newRecordID()
    zone := zoneID(r.Zone)
    address := r.Address
    names := r.Names

    hosts.recordIndex.Lock()
    hosts.recordIndex.index[id] = r
    hosts.recordIndex.zones[zone] = append(hosts.recordIndex.zones[zone], r)
    hosts.recordIndex.addresses[address] = append(hosts.recordIndex.addresses[address], r)
    for _, n := range names </span><span class="cov8" title="1">{
        hosts.recordIndex.names[n] = append(hosts.recordIndex.names[n], r)
    }</span>
    <span class="cov8" title="1">hosts.recordIndex.Unlock()

    r.ID = int(id)
    r.id = id

    return</span>
}

func removeRecord(r *Record) <span class="cov8" title="1">{
    if r.id == 0 </span><span class="cov8" title="1">{
        // file not indexed yet/anymore
        return
    }</span>

    <span class="cov8" title="1">id := r.id
    zone := zoneID(r.Zone)
    address := r.Address
    names := r.Names

    hosts.recordIndex.Lock()
    delete(hosts.recordIndex.index, id)
    hosts.recordIndex.zones[zone] = deleteFromSliceOfRecords(hosts.recordIndex.zones[zone], r)
    hosts.recordIndex.addresses[address] = deleteFromSliceOfRecords(hosts.recordIndex.addresses[address], r)
    for _, n := range names </span><span class="cov8" title="1">{
       hosts.recordIndex.names[n] = deleteFromSliceOfRecords(hosts.recordIndex.names[n], r)
    }</span>
    <span class="cov8" title="1">hosts.recordIndex.Unlock()

    r.ID = 0
    r.id = recordID(0)

    return</span>
}

func deleteFromSliceOfRecords(rs []*Record, r *Record) []*Record <span class="cov8" title="1">{
    if len(rs) == 0 </span><span class="cov8" title="1">{
        return []*Record(nil)   // always return a copy
    }</span>

    <span class="cov8" title="1">newRecords := make([]*Record, 0, len(rs) - 1)
    for _, record := range rs </span><span class="cov8" title="1">{
        if record == r </span><span class="cov8" title="1">{
            continue</span>
        }

        <span class="cov8" title="1">newRecords = append(newRecords, record)</span>
    }

    <span class="cov8" title="1">return newRecords</span>
}

// -----------------------------------------------------------------------------

type fileObject struct {
    data     []byte   // filled by goRenderFile(), cleared by goScanFile()
    checksum string
    file     *File    // !!! beware of memory leaks
}

func addFileObject(f *fileObject) <span class="cov8" title="1">{
    hosts.files = append(hosts.files, f)
    return
}</span>

func removeFileObject(f *fileObject) <span class="cov8" title="1">{
    hosts.files = deleteFromSliceOfFileObjects(hosts.files, f)
    return
}</span>

func deleteFromSliceOfFileObjects(fs []*fileObject, f *fileObject) []*fileObject <span class="cov8" title="1">{
    if len(fs) == 0 </span><span class="cov8" title="1">{
        return []*fileObject(nil)   // always return a copy
    }</span>

    <span class="cov8" title="1">newFileObjects := make([]*fileObject, 0, len(fs) - 1)
    for _, fileObject := range fs </span><span class="cov8" title="1">{
        if f == fileObject </span><span class="cov8" title="1">{
            continue</span>
        }
        <span class="cov8" title="1">newFileObjects = append(newFileObjects, fileObject)</span>
    }

    <span class="cov8" title="1">return newFileObjects</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">//
// Copyright (c) 2019 Stefaan Coussement
// MIT License
//
// more info: https://github.com/stefaanc/terraform-provider-hosts
//
package api

import (
    "crypto/sha1"
    "errors"
    "encoding/hex"
    "fmt"
    "io"
    "log"
    "strings"
)

// -----------------------------------------------------------------------------

type Record struct {
    // readOnly
    ID         int        // indexed   // read-write in a rQuery
    // read-writeOnce
    Zone       int        // indexed
    Address    string     // indexed
    Names      []string   // indexed
    // read-writeMany
    Comment    string
    Notes      string
    // private
    id         recordID
    zoneRecord *recordObject   // !!! beware of memory leaks
}

func LookupRecord(rQuery *Record) (r *Record) <span class="cov8" title="1">{
    // convert names to lower-case
    rQ := new(Record)
    if len(rQuery.Names) == 0 </span><span class="cov8" title="1">{
        rQ = rQuery
    }</span> else<span class="cov8" title="1"> {
        rQ.ID      = rQuery.ID
        rQ.Zone    = rQuery.Zone
        rQ.Address = rQuery.Address
        rQ.Names   = make([]string, len(rQuery.Names))
        for i, _ := range rQuery.Names </span><span class="cov8" title="1">{
            rQ.Names[i] = strings.ToLower(rQuery.Names[i])
        }</span>
    }

    <span class="cov8" title="1">rPrivate := lookupRecord(rQ)
    if rPrivate == nil </span><span class="cov8" title="1">{
        return nil
    }</span>

    // make a copy without the private fields
    <span class="cov8" title="1">r = new(Record)
    r.ID      = rPrivate.ID
    r.Zone    = rPrivate.Zone
    r.Address = rPrivate.Address
    r.Names   = make([]string, len(rPrivate.Names))
    copy(r.Names, rPrivate.Names)
    r.Comment = rPrivate.Comment
    r.Notes   = rPrivate.Notes
    // ignore computed fields

    return r</span>
}

func CreateRecord(rValues *Record) error <span class="cov8" title="1">{
    // convert names to lower-case
    rV := new(Record)
    if len(rValues.Names) == 0 </span><span class="cov8" title="1">{
        rV = rValues
    }</span> else<span class="cov8" title="1"> {
        rV.Zone    = rValues.Zone
        rV.Address = rValues.Address
        rV.Names   = make([]string, len(rValues.Names))
        for i, _ := range rValues.Names </span><span class="cov8" title="1">{
            rV.Names[i] = strings.ToLower(rValues.Names[i])
        }</span>
        <span class="cov8" title="1">rV.Comment = rValues.Comment
        rV.Notes   = rValues.Notes</span>
    }

    <span class="cov8" title="1">if rV.Zone == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateRecord(rValues)] missing 'rValues.Zone'")
    }</span>
    <span class="cov8" title="1">if rV.Address == "" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateRecord(rValues)] missing 'rValues.Address'")
    }</span>
    <span class="cov8" title="1">if len(rV.Names) == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateRecord(rValues)] missing 'rValues.Names'")
    }</span>

    // check zone
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.ID = rV.Zone
    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Update(rValues)] zone 'rValues.Zone' not found")
    }</span>
    <span class="cov8" title="1">if zPrivate.Name == "external" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateRecord(rValues)] cannot create records in the \"external\" zone")
    }</span>

    // lookup all names
    <span class="cov8" title="1">for _, name := range rV.Names </span><span class="cov8" title="1">{
        // check addresses for every name
        rQuery := new(Record)
        rQuery.Names = []string{ strings.ToLower(name) }
        rs := queryRecords(rQuery)
        if len(rs) &gt; 0 </span><span class="cov8" title="1">{
            if rs[0].Address == rV.Address </span><span class="cov8" title="1">{
                return fmt.Errorf("[ERROR][terraform-provider-hosts/api/CreateRecord(rValues)] another record with name %q already exists", name)
            }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("[ERROR][terraform-provider-hosts/api/CreateRecord(rValues)] another record with name %q but with different address %q already exists", name, rs[0].Address)
            }</span>
        }
    }

    <span class="cov8" title="1">return createRecord(rV)</span>   // rV.ID will be ignored
}

func (r *Record) Read() (record *Record, err error) <span class="cov8" title="1">{
    if r.ID == 0 </span><span class="cov8" title="1">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/r.Read()] missing 'r.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">rQuery := new(Record)
    rQuery.ID = r.ID
    rPrivate := lookupRecord(rQuery)
    if rPrivate == nil </span><span class="cov8" title="1">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/r.Read()] record 'r.ID' not found")
    }</span>

    // check zone
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.ID = rPrivate.Zone
    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov8" title="1">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/r.Update(rValues)] zone 'r.Zone' not found")
    }</span>

    // read record
    <span class="cov8" title="1">rPrivate, err = readRecord(rPrivate)
    if err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>

    // make a copy without the private fields
    <span class="cov8" title="1">record = new(Record)
    record.ID      = rPrivate.ID
    record.Zone    = rPrivate.Zone
    record.Address = rPrivate.Address
    record.Names   = make([]string, len(rPrivate.Names))
    copy(record.Names, rPrivate.Names)
    record.Comment = rPrivate.Comment
    record.Notes   = rPrivate.Notes
    // no computed fields

    return record, nil</span>
}

func (r *Record) Update(rValues *Record) error <span class="cov8" title="1">{
    if r.ID == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Update(rValues)] missing 'r.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">rQuery := new(Record)
    rQuery.ID = r.ID
    rPrivate := lookupRecord(rQuery)
    if rPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Update(rValues)] record 'r.ID' not found")
    }</span>

    // check zone
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.ID = rPrivate.Zone
    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Update(rValues)] zone 'r.Zone' not found")
    }</span>
    <span class="cov8" title="1">if zPrivate.Name == "external" </span><span class="cov8" title="1">{
        if rValues.Comment != rPrivate.Comment </span><span class="cov8" title="1">{
            return errors.New("[ERROR][terraform-provider-hosts/api/r.Update(rValues)] cannot update 'r.Comment' for records in the \"external\" zone")
        }</span>
    }

    <span class="cov8" title="1">return updateRecord(rPrivate, rValues)</span>   // rValues.ID and rValues.Zone will be ignored
}

func (r *Record) Delete() error <span class="cov8" title="1">{
    if r.ID == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Delete()] missing 'r.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">rQuery := new(Record)
    rQuery.ID = r.ID
    rPrivate := lookupRecord(rQuery)
    if rPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Delete()] record 'r.ID' not found")
    }</span>

    // check zone
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.ID = rPrivate.Zone
    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Delete()] zone 'r.Zone' not found")
    }</span>
    <span class="cov8" title="1">if zPrivate.Name == "external" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Delete()] cannot delete records in the \"external\" zone")
    }</span>

    <span class="cov8" title="1">return deleteRecord(rPrivate)</span>
}

// -----------------------------------------------------------------------------
//
// naming guidelines:
//
// - (r *Record)         the result of the public CreateRecord method and LookupRecord method
//                           this doesn't include the computed fields (always use a read method to get the computed fields)
//                           this doesn't include private fields
//
//                       the result of the private createRecord method and lookupRecord method (hosts.go)
//                           this doesn't include the computed fields (always use a read method to get the computed fields)
//
//                       the anchor for the public Read/Update/Delete methods
//                           this must include the 'ID' field
//
//                       the input for the private readRecord/updateRecord/deleteRecord methods
//                           this must include the private 'id' field
//
// - (rQuery *Record)    the input for the public LookupRecord method
//                       the input for the private lookupRecord method (hosts.go)
//                           this should include at least one of the indexed fields
//
//   (rValues *Record)   the input for the public CreateRecord/Update methods
//                       the input for the private createRecord/updateRecord methods
//                           for a create method, this must include *all* writeMany and writeOnce fields
//                           for an update method, this must include *all* writeMany fields
//
// - (record *Record)    the result of the public Read method
//                       the result of the private readRecord method
//                           this does include all computed fields
//
// -----------------------------------------------------------------------------

func createRecord(rValues *Record) error <span class="cov8" title="1">{
    // create record
    r := new(Record)
    r.Zone       = rValues.Zone
    r.Address    = rValues.Address
    r.Names      = make([]string, len(rValues.Names))
    copy(r.Names, rValues.Names)
    r.Comment    = rValues.Comment
    r.Notes      = rValues.Notes

    addRecord(r)   // updates r.ID and r.id

    if rValues.zoneRecord == nil </span><span class="cov8" title="1">{   // if requested by CreateRecord()
        // add the record to the zone
        zoneRecord := new(recordObject)
        zoneRecord.record = r       // !!! beware of memory leaks
        r.zoneRecord = zoneRecord   // !!! beware of memory leaks

        zQuery := new(Zone)
        zQuery.ID = r.Zone
        z := lookupZone(zQuery)
        addRecordObject(z, zoneRecord)
    
        // render record
        renderRecord(r)   // updates lines &amp; checksum

        // update zone
        err := updateZone(z, z)
        if err != nil </span><span class="cov8" title="1">{
            // restore consistent state
            removeRecordObject(z, zoneRecord)
            r.zoneRecord = nil   // !!! avoid memory leaks
            removeRecord(r)

            return err
        }</span>
    } else<span class="cov8" title="1"> {                         // requested by goScanRecord()
        // update record &amp; recordObject
        r.zoneRecord = rValues.zoneRecord   // !!! beware of memory leaks
        r.zoneRecord.record = r             // !!! beware of memory leaks
    }</span>

    <span class="cov8" title="1">log.Printf("[INFO][terraform-provider-hosts/api/createRecord()] created zone %d, record %q - %#v\n", r.Zone, r.Address, r.Names)
    return nil</span>
}

func readRecord(r *Record) (record *Record, err error) <span class="cov8" title="1">{
    // read zone
    zQuery := new(Zone)
    zQuery.ID = r.Zone
    z := lookupZone(zQuery)
    _, err = readZone(z)
    if err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>

    // don't return r, instead lookup record
    // - to cover case where record was deleted by external programs
    <span class="cov8" title="1">rQuery := new(Record)
    rQuery.ID = r.ID
    record = lookupRecord(rQuery)

    // no computed fields

    if record != nil </span><span class="cov8" title="1">{
        log.Printf("[INFO][terraform-provider-hosts/api/readRecord()] read zone %d, record %q - %#v\n", record.Zone, record.Address, record.Names)
    }</span>
    <span class="cov8" title="1">return record, nil</span>
}

func updateRecord(r *Record, rValues *Record) error <span class="cov8" title="1">{
    comment := r.Comment   // save so we can restore if needed
    notes   := r.Notes     // save so we can restore if needed
    oldChecksum := r.zoneRecord.checksum   // save to compare old with new

    // update record
    r.Comment  = rValues.Comment
    r.Notes    = rValues.Notes

    if rValues.zoneRecord == nil || r == rValues </span><span class="cov8" title="1">{   // if requested by r.Update() or if forcing a render/write
        zQuery := new(Zone)
        zQuery.ID = r.Zone
        z := lookupZone(zQuery)
        if z.Name != "external" </span><span class="cov8" title="1">{
            // render record to calculate new checksum
            renderRecord(r)   // updates lines &amp; checksum
            
            if r.zoneRecord.checksum != oldChecksum </span><span class="cov8" title="1">{
                // update zone
                err := updateZone(z, z)
                if err != nil </span><span class="cov8" title="1">{
                    // restore consistent state
                    r.Comment = comment
                    r.Notes   = notes
                    renderRecord(r)

                    return err
                }</span>
            }
        }
    } else<span class="cov8" title="1"> {                         // requested by goScanRecord()
        // update record &amp; recordObject
        r.zoneRecord = rValues.zoneRecord   // !!! beware of memory leaks
        r.zoneRecord.record = r             // !!! beware of memory leaks
    }</span>

    <span class="cov8" title="1">log.Printf("[INFO][terraform-provider-hosts/api/updateRecord()] updated zone %d, record %q - %#v\n", r.Zone, r.Address, r.Names)
    return nil</span>
}

func deleteRecord(r *Record) error <span class="cov8" title="1">{
    // remove the record from the zone
    if r.zoneRecord != nil </span><span class="cov8" title="1">{   // if requested by r.Delete()
        zQuery := new(Zone)
        zQuery.ID = r.Zone
        z := lookupZone(zQuery)

        removeRecordObject(z, r.zoneRecord)
        oldZoneRecord := r.zoneRecord   // save so we can restore if needed
        r.zoneRecord = nil              // !!! avoid memory leaks

        err := updateZone(z, z)
        if err != nil </span><span class="cov8" title="1">{
            // restore consistent state
            r.zoneRecord = oldZoneRecord   // !!! beware of memory leaks
            addRecordObject(z, r.zoneRecord)

            return err
        }</span>
    }

    // save for logging
    <span class="cov8" title="1">zone := r.Zone
    address := r.Address
    names := r.Names

    // remove and zero record
    removeRecord(r)   // zeroes r.ID and r.id

    r.Zone       = 0
    r.Address    = ""
    r.Names      = []string(nil)
    r.Comment    = ""
    r.Notes      = ""

    log.Printf("[INFO][terraform-provider-hosts/api/deleteRecord()] deleted zone %d, record %q - %#v\n", zone, address, names)
    return nil</span>
}

// -----------------------------------------------------------------------------

func renderRecord(r *Record) <span class="cov8" title="1">{
    // render strings
    rendered := make([]string, 0, 1)                                            // at this moment we support only single-line records

    line := r.Address

    for _, name := range r.Names </span><span class="cov8" title="1">{
        line += " " + name
    }</span>

    <span class="cov8" title="1">if r.Comment != "" </span><span class="cov8" title="1">{
        line += " # " + r.Comment
    }</span>

    <span class="cov8" title="1">rendered = append(rendered, line)

    // calculate checksum for the line
    checksum := sha1.Sum([]byte(line))

    // update recordObject
    r.zoneRecord.lines = rendered
    r.zoneRecord.checksum = hex.EncodeToString(checksum[:])

    return</span>
}

// -----------------------------------------------------------------------------

func goScanRecord(z *Zone, zoneRecord *recordObject, lines &lt;-chan string) chan bool <span class="cov8" title="1">{
    done := make(chan bool)

    go func() </span><span class="cov8" title="1">{
        defer close(done)

        // create a hash for the checksum of the record
        hash := sha1.New()
        
        // collect lines
        collected := make([]string, 0)
        for line := range lines </span><span class="cov8" title="1">{
            // update hash
            _, _ = io.WriteString(hash, line)

            // update lines
            collected = append(collected, line)
        }</span>
        <span class="cov8" title="1">if len(collected) == 0 </span><span class="cov8" title="1">{
            done &lt;- true
            return
        }</span>

        // calculate checksum for the lines
        <span class="cov8" title="1">checksum := hash.Sum(nil)
        zoneRecord.checksum = hex.EncodeToString(checksum[:])   // we cannot check if checksum changed because we need to parse the lines to know which record this is

        // update recordObject
        zoneRecord.lines = collected

        // process lines                                                        // at this moment we support only single-line records

        // split the line in an information-part and a comment-part
        parts := strings.SplitN(zoneRecord.lines[0], "#", 2)

        if parts[0] == "" </span><span class="cov8" title="1">{
            // the line doesn't have an information-part
            done &lt;- true
            return
        }</span>

        <span class="cov8" title="1">comment := ""
        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
            comment = strings.TrimRight(parts[1], " \t")
            if z.Name != "external" </span><span class="cov8" title="1">{
                // drop the leading space in the comment
                comment = strings.TrimPrefix(comment, " ")
            }</span>
        }

        // split the information-part
        <span class="cov8" title="1">parts = strings.Fields(parts[0])

        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
            // the information-part doesn't have both an address and a name
            log.Printf("[WARNING][terraform-provider-hosts/api/goScanRecord()] information-part doesn't have both an address and a name, skipping line: \n&gt; %q", zoneRecord.lines[0])

            done &lt;- true
            return
        }</span>

        // convert names to lower-case
        <span class="cov8" title="1">names := parts[1:]
        for i, _ := range names </span><span class="cov8" title="1">{
            names[i] = strings.ToLower(names[i])
        }</span>

        // create a new record if it doesn't exist, otherwise update it
        <span class="cov8" title="1">rQuery := new(Record)
        rQuery.Zone = z.ID
        rQuery.Address = parts[0]
        rQuery.Names = names
        r := lookupRecord(rQuery)

        if r == nil || len(r.Names) != len (rQuery.Names) </span><span class="cov8" title="1">{
            // create record
            rQuery.Comment = comment
            // rQuery.Notes   = ""   // notes are not saved in file

            rQuery.zoneRecord = zoneRecord
        
            _ = createRecord(rQuery)   // error cannot happen
        }</span> else<span class="cov8" title="1"> {
            // update record
            rQuery.Comment = comment
            rQuery.Notes   = r.Notes   // notes are not saved in file, need to pick up from old record

            rQuery.zoneRecord = zoneRecord
        
            _ = updateRecord(r, rQuery)   // error cannot happen
        }</span>

        <span class="cov8" title="1">done &lt;- true
        return</span>
    }()

    <span class="cov8" title="1">return done</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">//
// Copyright (c) 2019 Stefaan Coussement
// MIT License
//
// more info: https://github.com/stefaanc/terraform-provider-hosts
//
package api

import (
    "crypto/sha1"
    "errors"
    "encoding/hex"
    "io"
    "log"
    "strings"
)

// -----------------------------------------------------------------------------

type Zone struct {
    // readOnly
    ID       int      // indexed   // read-write in a zQuery
    // read-writeOnce
    File     int      // indexed
    Name     string   // indexed
    // read-writeMany
    Notes    string
    // private
    id       zoneID
    fileZone *zoneObject       // !!! beware of memory leaks
    records  []*recordObject   // !!! beware of memory leaks
}

func LookupZone(zQuery *Zone) (z *Zone) <span class="cov8" title="1">{
    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov8" title="1">{
        return nil
    }</span>

    // make a copy without the private fields
    <span class="cov8" title="1">z = new(Zone)
    z.ID    = zPrivate.ID
    z.File  = zPrivate.File
    z.Name  = zPrivate.Name
    z.Notes = zPrivate.Notes
    // ignore computed fields

    return z</span>
}

func CreateZone(zValues *Zone) error <span class="cov8" title="1">{
    if zValues.File == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateZone(zValues)] missing 'zValues.File'")
    }</span>
    <span class="cov8" title="1">if zValues.Name == "" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateZone(zValues)] missing 'zValues.Name'")
    }</span>
    <span class="cov8" title="1">if zValues.Name == "external" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateZone(zValues)] illegal value \"external\" specified for 'zValues.Name'")
    }</span>

    // check file
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.ID = zValues.File
    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateZone(zValues)] file 'zValues.File' not found")
    }</span>

    // lookup all indexed fields except ID
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.File = zValues.File
    zQuery.Name = zValues.Name
    zPrivate := lookupZone(zQuery)
    if zPrivate != nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateZone(zValues)] another zone with similar properties already exists")
    }</span>

    <span class="cov8" title="1">return createZone(zValues)</span>   // zValues.ID will be ignored
}

func (z *Zone) Read() (zone *Zone, err error) <span class="cov8" title="1">{
    if z.ID == 0 </span><span class="cov8" title="1">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/z.Read()] missing 'z.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.ID = z.ID

    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov8" title="1">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/z.Read()] zone 'z.ID' not found")
    }</span>

    // check file
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.ID = zPrivate.File
    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/z.Read()] file 'z.File' not found")
    }</span>

    // read zone
    <span class="cov8" title="1">zPrivate, err = readZone(zPrivate)
    if err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>

    // make a copy without the private fields
    <span class="cov8" title="1">zone = new(Zone)
    zone.ID      = zPrivate.ID
    zone.File    = zPrivate.File
    zone.Name    = zPrivate.Name
    zone.Notes   = zPrivate.Notes
    // no computed fields

    return zone, nil</span>
}

func (z *Zone) Update(zValues *Zone) error <span class="cov8" title="1">{
    if z.ID == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Update(zValues)] missing 'z.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.ID = z.ID

    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Update(zValues)] zone 'z.ID' not found")
    }</span>

    // check file
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.ID = zPrivate.File
    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Read()] file 'z.File' not found")
    }</span>

    <span class="cov8" title="1">return updateZone(zPrivate, zValues)</span>   // zValues.ID, zValues.Name and zValues.File will be ignored
}

func (z *Zone) Delete() error <span class="cov8" title="1">{
    if z.ID == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Delete(zValues)] missing 'z.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.ID = z.ID

    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Delete()] zone 'z.ID' not found")
    }</span>
    <span class="cov8" title="1">if zPrivate.Name == "external" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Delete()] cannot delete zone \"external\"")
    }</span>

    // check file
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.ID = zPrivate.File
    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Read()] file 'z.File' not found")
    }</span>

    <span class="cov8" title="1">return deleteZone(zPrivate)</span>
}

// -----------------------------------------------------------------------------
//
// naming guidelines:
//
// - (z *Zone)         the result of the public CreateFile method and LookupFile method
//                         this doesn't include the computed fields (always use a read method to get the computed fields)
//                         this doesn't include the private fields
//
//                     the result of the private createFile method and lookupFile method (hosts.go)
//                         this doesn't include the computed fields (always use a read method to get the computed fields)
//
//                     the anchor for the public Read/Update/Delete methods
//                         this must include the 'ID' field
//
//                     the input for the private read/update/delete methods
//                         this must include the private 'id' field
//
// - (zQuery *Zone)    the input for the public LookupFile method
//                     the input for the private lookupFile method (hosts.go)
//                         this should include at least one of the indexed fields
//
//   (zValues *Zone)   the input for the public CreateFile/Update methods
//                     the input for the private createFile/update methods
//                         for a create method, this must include *all* writeMany and writeOnce fields
//                         for an update method, this must include *all* writeMany fields
//
// - (zone *Zone)      the result of the public Read method
//                     the result of the private read method
//                         this does include all computed fields
//
// -----------------------------------------------------------------------------

func createZone(zValues *Zone) error <span class="cov8" title="1">{
    // create zone
    z := new(Zone)
    z.File     = zValues.File
    z.Name     = zValues.Name
    z.Notes    = zValues.Notes

    addZone(z)   // adds z.ID and z.id

    if zValues.fileZone == nil </span><span class="cov8" title="1">{   // if requested by CreateZone()
        // add the zone to the file
        fileZone := new(zoneObject)
        fileZone.zone = z       // !!! beware of memory leaks
        z.fileZone = fileZone   // !!! beware of memory leaks

        fQuery := new(File)
        fQuery.ID = z.File
        f := lookupFile(fQuery)
        addZoneObject(f, fileZone)
    
        // render zone
        renderZone(z)   // updates lines &amp; checksum

        // update file
        err := updateFile(f, f)
        if err != nil </span><span class="cov8" title="1">{
            // restore consistent state
            removeZoneObject(f, fileZone)
            z.fileZone = nil   // !!! avoid memory leaks
            removeZone(z)

            return err
        }</span>
    } else<span class="cov8" title="1"> {                       // requested by goScanZone()
        // update zone &amp; zoneObject
        z.fileZone = zValues.fileZone   // !!! beware of memory leaks
        z.fileZone.zone = z             // !!! beware of memory leaks
    }</span>

    <span class="cov8" title="1">log.Printf("[INFO][terraform-provider-hosts/api/createZone()] created file %d, zone %q\n", z.File, z.Name)
    return nil</span>
}

func readZone(z *Zone) (zone *Zone, err error) <span class="cov8" title="1">{
    // read file
    fQuery := new(File)
    fQuery.ID = z.File
    f := lookupFile(fQuery)
    _, err = readFile(f)
    if err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>

    // don't return z, instead lookup zone
    // - to cover case where zone was deleted by external programs
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.ID = z.ID
    zone = lookupZone(zQuery)

    // no computed fields
    if zone != nil </span><span class="cov8" title="1">{
        log.Printf("[INFO][terraform-provider-hosts/api/readZone()] read file %d, zone %q\n", zone.File, zone.Name)
    }</span>
    <span class="cov8" title="1">return zone, nil</span>
}

func updateZone(z *Zone, zValues *Zone) error <span class="cov8" title="1">{
    notes   := z.Notes     // save so we can restore if needed
    oldLines    := z.fileZone.lines      // save so we can restore if needed
    oldChecksum := z.fileZone.checksum   // save to compare old with new

    // update zone
    z.Notes    = zValues.Notes

    if zValues.fileZone == nil || z == zValues </span><span class="cov8" title="1">{   // if requested by z.Update() or if forcing a render/write
        // render zone to calculate new checksum
        renderZone(z)   // updates lines &amp; checksum
        
        if z.fileZone.checksum != oldChecksum </span><span class="cov8" title="1">{
            // update file
            fQuery := new(File)
            fQuery.ID = z.File
            f := lookupFile(fQuery)
            err := updateFile(f, f)
            if err != nil </span><span class="cov8" title="1">{
                // restore consistent state
                z.Notes    = notes
                z.fileZone.lines    = oldLines
                z.fileZone.checksum = oldChecksum

                return err
            }</span>
        }
    } else<span class="cov8" title="1"> {                       // requested by goScanZone()
        // update zone &amp; zoneObject
        z.fileZone = zValues.fileZone   // !!! beware of memory leaks
        z.fileZone.zone = z             // !!! beware of memory leaks
    }</span>

    <span class="cov8" title="1">log.Printf("[INFO][terraform-provider-hosts/api/updateZone()] updated file %d, zone %q\n", z.File, z.Name)
    return nil</span>
}

func deleteZone(z *Zone) error <span class="cov8" title="1">{
    // remove the zone from the file
    if z.fileZone != nil </span><span class="cov8" title="1">{   // if requested by z.Delete()
        fQuery := new(File)
        fQuery.ID = z.File
        f := lookupFile(fQuery)

        removeZoneObject(f, z.fileZone)
        oldFileZone := z.fileZone   // save so we can restore if needed
        z.fileZone = nil            // !!! avoid memory leaks

        err := updateFile(f, f)
        if err != nil </span><span class="cov8" title="1">{
            // restore consistent state
            z.fileZone = oldFileZone   // !!! beware of memory leaks
            addZoneObject(f, z.fileZone)

            return err
        }</span>
    }

    // save for logging
    <span class="cov8" title="1">file := z.File
    name := z.Name

    // remove and zero zone object
    removeZone(z)   // zeroes z.ID and z.id

    z.File     = 0
    z.Name     = ""
    z.Notes    = ""

    for _, recordObject := range z.records </span><span class="cov8" title="1">{   // !!! avoid memory leaks
        recordObject.record = nil
    }</span>
    <span class="cov8" title="1">z.records  = []*recordObject(nil)

    log.Printf("[INFO][terraform-provider-hosts/api/deleteZone()] deleted file %d, zone %q\n", file, name)
    return nil</span>
}

// -----------------------------------------------------------------------------

var startZoneMarker string = "##### Start Of Terraform Zone: "
var endZoneMarker string   = "##### End Of Terraform Zone: "

// -----------------------------------------------------------------------------

func renderZone(z *Zone) <span class="cov8" title="1">{
    // create a hash for the checksum of the zone
    hash := sha1.New()

    // render strings
    rendered := make([]string, 0)

    // render marker
    line := startZoneMarker + z.Name + " #####"
    padding := 80 - len(line)
    if padding &lt; 0 </span><span class="cov8" title="1">{ padding = 0 }</span>
    <span class="cov8" title="1">line += strings.Repeat("#", padding)

    // update hash
    _, _ = io.WriteString(hash, line)   // error cannot happen
    _, _ = io.WriteString(hash, "\n")   // error cannot happen

    // update lines
    rendered = append(rendered, line)

    for _, recordObject := range z.records </span><span class="cov8" title="1">{
        // update hash
        _, _ = io.WriteString(hash, recordObject.lines[0])   // error cannot happen   // at this moment we support only single-line records
        _, _ = io.WriteString(hash, "\n")                    // error cannot happen

        // update lines
        rendered = append(rendered, recordObject.lines[0])                      // at this moment we support only single-line records
    }</span>

    // render marker
    <span class="cov8" title="1">line = endZoneMarker + z.Name + " #####"
    padding = 80 - len(line)
    if padding &lt; 0 </span><span class="cov8" title="1">{ padding = 0 }</span>
    <span class="cov8" title="1">line += strings.Repeat("#", padding)

    // update hash
    _, _ = io.WriteString(hash, line)   // error cannot happen
    _, _ = io.WriteString(hash, "\n")   // error cannot happen

    // update lines
    rendered = append(rendered, line)

    // calculate checksum for the lines
    checksum := hash.Sum(nil)

    // update zoneObject
    z.fileZone.lines = rendered
    z.fileZone.checksum = hex.EncodeToString(checksum[:])

    return</span>
}

// -----------------------------------------------------------------------------

func goScanZone(f *File, fileZone *zoneObject, lines &lt;-chan string) chan bool <span class="cov8" title="1">{
    done := make(chan bool)

    go func() </span><span class="cov8" title="1">{
        defer close(done)

        // create a hash for the checksum of the zone
        hash := sha1.New()

        // scan first line, possibly a start-zone-marker
        var line string
        var receivedLine bool
        for line = range lines </span><span class="cov8" title="1">{   // using for to cover case where lines channel is closed before a line is sent - applicable to files without external records
            receivedLine = true
            break</span>
        }
        <span class="cov8" title="1">if !receivedLine </span><span class="cov8" title="1">{
            done &lt;- true
            return
        }</span>

        // get zone name
        <span class="cov8" title="1">var zone string
        isStartMarker := strings.HasPrefix(line, startZoneMarker)
        if isStartMarker </span><span class="cov8" title="1">{
            zone = strings.Trim(line[len(startZoneMarker):], " #")
        }</span> else<span class="cov8" title="1"> {
            zone = "external"
        }</span>

        // update hash
        <span class="cov8" title="1">_, _ = io.WriteString(hash, line)   // error cannot happen
        _, _ = io.WriteString(hash, "\n")   // error cannot happen

        // create/update zone
        zQuery := new(Zone)
        zQuery.File = f.ID
        zQuery.Name = zone
        z := lookupZone(zQuery)

        var oldChecksum string
        if z == nil </span><span class="cov8" title="1">{
            // create zone
            // zQuery.Notes   = ""   // notes are not saved in file

            zQuery.fileZone = fileZone

            _ = createZone(zQuery)   // error cannot happen
            z = lookupZone(zQuery)
        }</span> else<span class="cov8" title="1"> {
            // pickup old checksum
            oldChecksum = z.fileZone.checksum

            // update zone
            zQuery.Notes   = z.Notes   // notes are not saved in file, need to pick up from old zone

            zQuery.fileZone = fileZone
        
            _ = updateZone(z, zQuery)   // error cannot happen
        }</span>

        // keep the old slice of recordObjects to cleanup old records that aren't replaced
        <span class="cov8" title="1">oldRecords := z.records

        // update zone with new slice of recordObjects
        z.records = make([]*recordObject, 0)

        defer func() </span><span class="cov8" title="1">{
            // cleanup records that aren't replaced
            for _, zoneRecord := range oldRecords </span><span class="cov8" title="1">{
                r := zoneRecord.record
                if r != nil </span><span class="cov8" title="1">{   // if zoneRecord is a record, not a comment/blank-line
                    if r.zoneRecord == zoneRecord </span><span class="cov8" title="1">{   // if record was deleted from the read zone, zoneRecord was not replaced
                        // delete record object
                        r.zoneRecord = nil   // !!! avoid memory leaks
                        _ = deleteRecord(r)   // error cannot happen
                    }</span>
                }
            }
        }()

        // update zone
        <span class="cov8" title="1">if !isStartMarker </span><span class="cov8" title="1">{
            zoneRecord := new(recordObject)
            zoneRecord.lines = append(zoneRecord.lines, line)                   // at this moment we support only single-line records
            addRecordObject(z, zoneRecord)
        }</span>

        // collect lines
        <span class="cov8" title="1">for line := range lines </span><span class="cov8" title="1">{

            if strings.HasPrefix(line, endZoneMarker) </span><span class="cov8" title="1">{
                if len(line) == len(endZoneMarker) </span><span class="cov8" title="1">{
                    // no zone name in end-marker - goScanFile probably inserted anonymous endZoneMarker
                    // render missing marker
                    line = endZoneMarker + zone + " #####"
                    padding := 80 - len(line)
                    if padding &lt; 0 </span><span class="cov8" title="1">{ padding = 0 }</span>
                    <span class="cov8" title="1">line += strings.Repeat("#", padding)
                    fileZone.lines = append(fileZone.lines, line)</span>
                }

                // update hash
                <span class="cov8" title="1">_, _ = io.WriteString(hash, line)   // error cannot happen
                _, _ = io.WriteString(hash, "\n")   // error cannot happen

                // end of zone
                if !strings.HasPrefix(line, endZoneMarker + zone) </span><span class="cov8" title="1">{
                    // unexpected endZoneMarker, probably an endZone- and startZone-Marker missing =&gt; silently ignore
                    // all records from the zone with missing startZoneMarker will be in the current zone
                    log.Printf("[WARNING][terraform-provider-hosts/api/goScanZone()] unexpected end-of-zone marker - missing end-of-zone and start-of-zone marker: \n&gt; %q\n", line)
                }</span>

                <span class="cov8" title="1">break</span>
            } else<span class="cov8" title="1"> {
                // update hash
                _, _ = io.WriteString(hash, line)   // error cannot happen
                _, _ = io.WriteString(hash, "\n")   // error cannot happen
            }</span>

            <span class="cov8" title="1">zoneRecord := new(recordObject)
            zoneRecord.lines = append(zoneRecord.lines, line)               // at this moment we support only single-line records
            addRecordObject(z, zoneRecord)</span>
        }

        // calculate checksum for the lines
        <span class="cov8" title="1">checksum := hash.Sum(nil)
        fileZone.checksum = hex.EncodeToString(checksum[:])

        if fileZone.checksum == oldChecksum </span><span class="cov8" title="1">{
            done &lt;- true
            return
        }</span>

        // process lines
        <span class="cov8" title="1">for _, zoneRecord := range z.records </span><span class="cov8" title="1">{
            lines2 := make(chan string)
            done2 := goScanRecord(z, zoneRecord, lines2)

            lines2 &lt;- zoneRecord.lines[0]                                        // at this moment we support only single-line records

            close(lines2)
            _ = &lt;-done2
        }</span>

        <span class="cov8" title="1">done &lt;- true
        return</span>
    }()

    <span class="cov8" title="1">return done</span>
}

// -----------------------------------------------------------------------------

type recordObject struct {
    // remark that a record can be split over multiple lines
    // - f.i. a comment-line before to information-line
    // - f.i. names split over several lines
    lines    []string
    checksum string
    // remark that a recordObject may not have an associated record
    // - f.i. a comment-line in the external zone of the hosts-file
    record   *Record   // !!! beware of memory leaks
}

func addRecordObject(z *Zone, r *recordObject) <span class="cov8" title="1">{
    z.records = append(z.records, r)
    return
}</span>

func removeRecordObject(z *Zone, r *recordObject) <span class="cov8" title="1">{
    z.records = deleteFromSliceOfRecordObjects(z.records, r)
    return
}</span>

func deleteFromSliceOfRecordObjects(rs []*recordObject, r *recordObject) []*recordObject <span class="cov8" title="1">{
    if len(rs) == 0 </span><span class="cov8" title="1">{
        return []*recordObject(nil)   // always return a copy
    }</span>

    <span class="cov8" title="1">newRecordObjects := make([]*recordObject, 0, len(rs) - 1)
    for _, recordObject := range rs </span><span class="cov8" title="1">{
        if r == recordObject </span><span class="cov8" title="1">{
            continue</span>
        }
        <span class="cov8" title="1">newRecordObjects = append(newRecordObjects, recordObject)</span>
    }

    <span class="cov8" title="1">return newRecordObjects</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
