
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/stefaanc/terraform-provider-hosts/api/file.go (73.9%)</option>
				
				<option value="file1">github.com/stefaanc/terraform-provider-hosts/api/hosts.go (100.0%)</option>
				
				<option value="file2">github.com/stefaanc/terraform-provider-hosts/api/record.go (61.8%)</option>
				
				<option value="file3">github.com/stefaanc/terraform-provider-hosts/api/zone.go (64.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
    "bufio"
    "bytes"
    "crypto/sha1"
    "errors"
    "encoding/hex"
    //"fmt"
    "io"
    "io/ioutil"
    "os"
    "strings"
)

// -----------------------------------------------------------------------------

type File struct {
    // readOnly
    ID       int      // indexed   // read-write in a fQuery
    // read-writeOnce
    Path     string   // indexed   // read-write in a fQuery
    // read-writeMany
    Notes    string
    // private
    id       fileID
    checksum string
}

func LookupFile(fQuery *File) (f *File) <span class="cov8" title="1">{
    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return nil
    }</span>

    // make a copy without the private fields
    <span class="cov8" title="1">f = new(File)
    f.ID    = fPrivate.ID
    f.Path  = fPrivate.Path
    f.Notes = fPrivate.Notes
    // ignore computed fields

    return f</span>
}

func CreateFile(fValues *File) error <span class="cov8" title="1">{
    if fValues.Path == "" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateFile(fValues)] missing 'fValues.Path'")
    }</span>

    // lookup all indexed fields except ID
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.Path = fValues.Path

    fPrivate := lookupFile(fQuery)
    if fPrivate != nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateFile(fValues)] another file with similar properties already exists")
    }</span>

    <span class="cov8" title="1">return createFile(fValues)</span>   // fValues.ID will be ignored
}

func (f *File) Read() (file *File, err error) <span class="cov8" title="1">{
    if f.ID == 0 </span><span class="cov8" title="1">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/f.Read()] missing 'f.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.ID = f.ID

    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/f.Read()] file not found")
    }</span>

    <span class="cov8" title="1">fPrivate, err = readFile(fPrivate)
    if err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>

    // make a copy without the private fields
    <span class="cov8" title="1">file = new(File)
    file.ID    = fPrivate.ID
    file.Path  = fPrivate.Path
    file.Notes = fPrivate.Notes
    // no computed fields

    return file, nil</span>
}

func (f *File) Update(fValues *File) error <span class="cov8" title="1">{
    if f.ID == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/f.Update(fValues)] missing 'f.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.ID = f.ID

    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/f.Update(fValues)] file not found")
    }</span>

    <span class="cov8" title="1">return updateFile(fPrivate, fValues)</span>   // fValues.ID and fValues.Path will be ignored
}

func (f *File) Delete() error <span class="cov8" title="1">{
    if f.ID == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/f.Delete(fValues)] missing 'f.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">fQuery := new(File)
    fQuery.ID = f.ID

    fPrivate := lookupFile(fQuery)
    if fPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/f.Delete()] file not found")
    }</span>

    <span class="cov8" title="1">return deleteFile(fPrivate)</span>
}

// -----------------------------------------------------------------------------
//
// naming guidelines:
//
// - (f *File)         the result of the public CreateFile method and LookupFile method
//                         this doesn't include the computed fields (always use a read method to get the computed fields)
//                         this doesn't include the private fields
//
//                     the result of the private createFile method and lookupFile method (hosts.go)
//                         this doesn't include the computed fields (always use a read method to get the computed fields)
//
//                     the anchor for the public Read/Update/Delete methods
//                         this must include the 'ID' field
//
//                     the input for the private readFile/updateFile/deleteFile methods
//                         this must include the private 'id' field
//
// - (fQuery *File)    the input for the public LookupFile method
//                     the input for the private lookupFile method (hosts.go)
//                         this should include at least one of the indexed fields
//
//   (fValues *File)   the input for the public CreateFile/Update methods
//                     the input for the private createFile/updateFile methods
//                         for a create method, this must include *all* writeMany and writeOnce fields
//                         for an update method, this must include *all* writeMany fields
//
// - (file *File)      the result of the public Read method
//                     the result of the private readFile method
//                         this does include all computed fields
//
// -----------------------------------------------------------------------------

func createFile(fValues *File) error <span class="cov8" title="1">{
    // create and initialize file object
    f := new(File)
    f.Path = fValues.Path
    f.Notes = fValues.Notes

    addFile(f)   // adds f.ID and f.id

    // read physical file, if it doesn't exist then create it
    data, err := ioutil.ReadFile(f.Path)
    if err != nil </span><span class="cov8" title="1">{
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
            data = []byte(nil)
            err = ioutil.WriteFile(f.Path, data, 0644)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
            removeFile(f)                                                       // need to remove zones/records too !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            return err
        }</span>
    }
    <span class="cov8" title="1">checksum := sha1.Sum(data)
    f.checksum = hex.EncodeToString(checksum[:])

    // process data
    cerr := goScanZones(f, bytes.NewReader(data))
    err = &lt;-cerr
    if err != nil </span><span class="cov0" title="0">{
        removeFile(f)                                                           // need to remove zones/records too !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        return err
    }</span>

    <span class="cov8" title="1">return nil</span>
}

func readFile(f *File) (file *File, err error) <span class="cov8" title="1">{
    // read physical file
    data, err := ioutil.ReadFile(f.Path)
    if err != nil </span><span class="cov8" title="1">{
        return nil, err
    }</span>
    <span class="cov8" title="1">checksum := sha1.Sum(data)
    newChecksum := hex.EncodeToString(checksum[:])

    if f.checksum != newChecksum </span><span class="cov8" title="1">{
        f.checksum = newChecksum

        // process data
        cerr := goScanZones(f, bytes.NewReader(data))
        err = &lt;-cerr
        if err != nil </span><span class="cov0" title="0">{
            return nil, err
        }</span>
    }

    <span class="cov8" title="1">return f, nil</span>
}

func updateFile(f *File, fValues *File) error <span class="cov8" title="1">{
    data:= []byte("# some updated data")                                        // TBD !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    checksum := sha1.Sum(data)                                                  // TBD
    f.checksum = hex.EncodeToString(checksum[:])                                // TBD

    err := ioutil.WriteFile(f.Path, data, 0644)
    if err != nil </span><span class="cov8" title="1">{
        return err
    }</span>

    <span class="cov8" title="1">return nil</span>
}

func deleteFile(f *File) error <span class="cov8" title="1">{
    path := f.Path

    // remove and zero file object
    f.Path = ""
    f.Notes = ""

    f.checksum = ""

    removeFile(f)   // zeroes f.ID and f.id

    // delete physical file
    err := os.Remove(path)
    if err != nil </span><span class="cov8" title="1">{
        return err
    }</span>

    <span class="cov8" title="1">return nil</span>
}

// -----------------------------------------------------------------------------

func goScanZones(f *File, r io.Reader) chan error <span class="cov8" title="1">{
    cerr := make(chan error)

    go func(cerr chan error) </span><span class="cov8" title="1">{
        defer close(cerr)

        startMarker := "##### Start Of Terraform Zone: "
        endMarker   := "##### End Of Terraform Zone: "

        // create a hash for the checksum of the file
//        hash := sha1.New()

        // create the default external zone
        zone := "external"

        zValues := new(Zone)
        zValues.File = f.ID
        zValues.Name = zone
        err := createZone(zValues)
        if err != nil </span><span class="cov0" title="0">{
            cerr &lt;- err
            return
        }</span>
        <span class="cov8" title="1">z := lookupZone(zValues)

        // create a channel to the external zone
        lines := make(chan string)
        cerr2 := goScanLines(z, lines)

        // save this channel for later use
        linesExternal := lines
        cerrExternal := cerr2

        // start scanning
//        firstLine := true
        scanner := bufio.NewScanner(r)
        for scanner.Scan() </span><span class="cov8" title="1">{
            line := scanner.Text()

            // update hash
            // in this case, it is safe ignore errors from io.WriteString
//            if firstLine {
//                firstLine = false
//                _, _ = io.WriteString(hash, line)
//            } else {
//                _, _ = io.WriteString(hash, "\n" + line)
//            }

            // scan line
            if lines == linesExternal </span><span class="cov8" title="1">{
                if strings.HasPrefix(line, startMarker) </span><span class="cov0" title="0">{
                    // line is a marker for the start of new zone
                    // create new zone
                    zone = strings.Trim(line[len(startMarker):], " #")

                    zValues = new(Zone)
                    zValues.File = f.ID
                    zValues.Name = zone
                    err = createZone(zValues)
                    if err != nil </span><span class="cov0" title="0">{
                        close(lines)
                        cerr &lt;- err
                        return
                    }</span>
                    <span class="cov0" title="0">z := lookupZone(zValues)

                    // create a channel to the new zone
                    lines = make(chan string)
                    cerr2 = goScanLines(z, lines)

                    continue</span>
                } 
            } else<span class="cov0" title="0"> {
                if strings.HasPrefix(line, endMarker + zone) </span><span class="cov0" title="0">{
                    // line is a marker for the end of current zone
                    // wait for goScanLines(z) of the current zone to finish
                    close(lines)
                    err = &lt;-cerr2
                    if err != nil </span><span class="cov0" title="0">{
                        if lines != linesExternal </span><span class="cov0" title="0">{
                            close(linesExternal)
                        }</span>
                        <span class="cov0" title="0">cerr &lt;- err
                        return</span>
                    }

                    // back to external zone
                    <span class="cov0" title="0">zone = "external"
                    lines = linesExternal
                    cerr2 = cerrExternal

                    continue</span>
                }
            }

            // line is not a marker =&gt; send to scanLines(z) it
            <span class="cov8" title="1">lines &lt;- line</span>
        }
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
            // scanner error
            close(lines)
            if lines != linesExternal </span><span class="cov0" title="0">{
                close(linesExternal)
            }</span>
            <span class="cov0" title="0">cerr &lt;- err
            return</span>
        }

        <span class="cov8" title="1">if lines != linesExternal </span><span class="cov0" title="0">{
            // missing end-marker for current zone =&gt; silently ignore
            // wait for goScanLines(z) of the current zone to finish
            close(lines)
            err = &lt;-cerr2
            if err != nil </span><span class="cov0" title="0">{
                close(linesExternal)
                cerr &lt;- err
                return
            }</span>
        }

        // wait for goScanLines(z) of the external zone to finish
        <span class="cov8" title="1">close(linesExternal)
        err = &lt;-cerrExternal
        if err != nil </span><span class="cov0" title="0">{
            cerr &lt;- err
            return
        }</span>

        // save checksum of the file
//        checksum := hash.Sum(nil)
//        f.checksum = hex.EncodeToString(checksum[:])

        // finish goScanZones(f, r)
        <span class="cov8" title="1">cerr &lt;- nil
        return</span>
    }(cerr)

    <span class="cov8" title="1">return cerr</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
)

// -----------------------------------------------------------------------------

func Init() <span class="cov8" title="1">{
    initHosts()
    return
}</span>

// -----------------------------------------------------------------------------

type anchor struct {
    newFileID func () fileID
    fileIndex map[fileID]*File
    filePaths map[string][]*File

    newZoneID func () zoneID
    zoneIndex map[zoneID]*Zone
    zoneFiles map[fileID][]*Zone
    zoneNames map[string][]*Zone

    newRecordID func () recordID
    recordIndex map[recordID]*Record
    recordZones map[zoneID][]*Record
    recordAddresses map[string][]*Record
    recordNames map[string][]*Record
}

var hosts *anchor

func initHosts() <span class="cov8" title="1">{
    if hosts != nil </span><span class="cov8" title="1">{
        // already initialized
        return
    }</span>

    <span class="cov8" title="1">hosts = new(anchor)

    lastFileID := fileID(0)
    hosts.newFileID = func() fileID </span><span class="cov8" title="1">{
        lastFileID += 1
        return lastFileID
    }</span>
    <span class="cov8" title="1">hosts.fileIndex = make(map[fileID]*File)
    hosts.filePaths = make(map[string][]*File)

    lastZoneID := zoneID(0)
    hosts.newZoneID = func() zoneID </span><span class="cov8" title="1">{
        lastZoneID += 1
        return lastZoneID
    }</span>
    <span class="cov8" title="1">hosts.zoneIndex = make(map[zoneID]*Zone)
    hosts.zoneFiles = make(map[fileID][]*Zone)
    hosts.zoneNames = make(map[string][]*Zone)

    lastRecordID := recordID(0)
    hosts.newRecordID = func() recordID </span><span class="cov8" title="1">{
        lastRecordID += 1
        return lastRecordID
    }</span>
    <span class="cov8" title="1">hosts.recordIndex = make(map[recordID]*Record)
    hosts.recordZones = make(map[zoneID][]*Record)
    hosts.recordAddresses = make(map[string][]*Record)
    hosts.recordNames = make(map[string][]*Record)</span>
}

// -----------------------------------------------------------------------------

type fileID int

func lookupFile(fQuery *File) (f *File) <span class="cov8" title="1">{
    if fQuery.id != 0 </span><span class="cov8" title="1">{
        return fQuery
    }</span>

    <span class="cov8" title="1">if fQuery.ID != 0 </span><span class="cov8" title="1">{
        f := hosts.fileIndex[fileID(fQuery.ID)]
        if f == nil </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying properties
        <span class="cov8" title="1">if fQuery.Path != "" &amp;&amp; fQuery.Path != f.Path </span><span class="cov8" title="1">{
            return nil
        }</span>

        <span class="cov8" title="1">return f</span>
    }

    <span class="cov8" title="1">if fQuery.Path != "" </span><span class="cov8" title="1">{
        fs := hosts.filePaths[fQuery.Path]

        if len(fs) != 1 </span><span class="cov8" title="1">{
            // if more than 1 valid record, 'get' cannot decide which one to return
            return nil
        }</span>

        <span class="cov8" title="1">return fs[0]</span>
    }

    <span class="cov8" title="1">return nil</span>
}

func addFile(f *File) <span class="cov8" title="1">{
    if f.id != 0 </span><span class="cov8" title="1">{
        // file already indexed
        return
    }</span>

    <span class="cov8" title="1">id := hosts.newFileID()
    path := f.Path

    hosts.fileIndex[id] = f
    hosts.filePaths[path] = append(hosts.filePaths[path], f)

    f.ID = int(id)
    f.id = id

    return</span>
}

func removeFile(f *File) <span class="cov8" title="1">{
    if f.id == 0 </span><span class="cov8" title="1">{
        // file not indexed yet/anymore
        return
    }</span>

    <span class="cov8" title="1">id := f.id
    path := f.Path

    delete(hosts.fileIndex, id)
    hosts.filePaths[path] = deleteFromSliceOfFiles(hosts.filePaths[path], f)

    f.ID = 0
    f.id = fileID(0)

    return</span>
}

func deleteFromSliceOfFiles(fs []*File, f *File) []*File <span class="cov8" title="1">{
    if len(fs) == 0 </span><span class="cov8" title="1">{
        return []*File(nil)   // always return a copy
    }</span>

    <span class="cov8" title="1">newFiles := make([]*File, len(fs) - 1)
    decr := 0
    for i, file := range fs </span><span class="cov8" title="1">{
        if file.id == f.id </span><span class="cov8" title="1">{
            decr = 1
        }</span> else<span class="cov8" title="1"> {
            newFiles[i-decr] = fs[i]
        }</span>
    }

    <span class="cov8" title="1">return newFiles</span>
}

// -----------------------------------------------------------------------------

type zoneID int

func lookupZone(zQuery *Zone) (z *Zone) <span class="cov8" title="1">{
    if zQuery.id != 0 </span><span class="cov8" title="1">{
        return zQuery
    }</span>

    <span class="cov8" title="1">if zQuery.ID != 0 </span><span class="cov8" title="1">{
        z := hosts.zoneIndex[zoneID(zQuery.ID)]
        if z == nil </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying properties
        <span class="cov8" title="1">if zQuery.File != 0 &amp;&amp; zQuery.File != z.File </span><span class="cov8" title="1">{
            return nil
        }</span>
        <span class="cov8" title="1">if zQuery.Name != "" &amp;&amp; zQuery.Name != z.Name </span><span class="cov8" title="1">{
            return nil
        }</span>

        <span class="cov8" title="1">return z</span>
    }

    <span class="cov8" title="1">if zQuery.Name != "" </span><span class="cov8" title="1">{
        zs := hosts.zoneNames[zQuery.Name]
        if len(zs) == 0 </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying properties
        <span class="cov8" title="1">if zQuery.File != 0 </span><span class="cov8" title="1">{
            zsReduced := make([]*Zone, 0)
            for _, candidate := range zs </span><span class="cov8" title="1">{
                // a valid candidate has a file equal to zQuery.File
                if candidate.File == zQuery.File </span><span class="cov8" title="1">{
                    zsReduced = append(zsReduced, candidate)
                }</span>
            }
            <span class="cov8" title="1">zs = zsReduced

            if len(zs) == 0 </span><span class="cov8" title="1">{
                return nil
            }</span>
        }
        
        <span class="cov8" title="1">if len(zs) != 1 </span><span class="cov8" title="1">{
            // if more than 1 valid zone, 'get' cannot decide which one to return
            return nil
        }</span>

        <span class="cov8" title="1">return zs[0]</span>
    }

    <span class="cov8" title="1">if zQuery.File != 0 </span><span class="cov8" title="1">{
        zs := hosts.zoneFiles[fileID(zQuery.File)]

        if len(zs) != 1 </span><span class="cov8" title="1">{
            // if more than 1 valid zone, 'get' cannot decide which one to return
            return nil
        }</span>

        <span class="cov8" title="1">return zs[0]</span>
    }

    <span class="cov8" title="1">return nil</span>
}

func addZone(z *Zone) <span class="cov8" title="1">{
    if z.id != 0 </span><span class="cov8" title="1">{
        // zone already indexed
        return
    }</span>

    <span class="cov8" title="1">id := hosts.newZoneID()
    file := fileID(z.File)
    name := z.Name

    hosts.zoneIndex[id] = z
    hosts.zoneFiles[file] = append(hosts.zoneFiles[file], z)
    hosts.zoneNames[name] = append(hosts.zoneNames[name], z)

    z.ID = int(id)
    z.id = id

    return</span>
}

func removeZone(z *Zone) <span class="cov8" title="1">{
    if z.id == 0 </span><span class="cov8" title="1">{
        // file not indexed yet/anymore
        return
    }</span>

    <span class="cov8" title="1">id := z.id
    file := fileID(z.File)
    name := z.Name

    delete(hosts.zoneIndex, id)
    hosts.zoneFiles[file] = deleteFromSliceOfZones(hosts.zoneFiles[file], z)
    hosts.zoneNames[name] = deleteFromSliceOfZones(hosts.zoneNames[name], z)

    z.ID = 0
    z.id = zoneID(0)

    return</span>
}

func deleteFromSliceOfZones(zs []*Zone, z *Zone) []*Zone <span class="cov8" title="1">{
    if len(zs) == 0 </span><span class="cov8" title="1">{
        return []*Zone(nil)   // always return a copy
    }</span>

    <span class="cov8" title="1">newZones := make([]*Zone, len(zs) - 1)
    decr := 0
    for i, zone := range zs </span><span class="cov8" title="1">{
        if zone.id == z.id </span><span class="cov8" title="1">{
            decr = 1
        }</span> else<span class="cov8" title="1"> {
            newZones[i-decr] = zs[i]
        }</span>
    }

    <span class="cov8" title="1">return newZones</span>
}

// -----------------------------------------------------------------------------

type recordID int

func lookupRecord(rQuery *Record) (r *Record) <span class="cov8" title="1">{
    if rQuery.id != 0 </span><span class="cov8" title="1">{
        return rQuery
    }</span>

    <span class="cov8" title="1">if rQuery.ID != 0 </span><span class="cov8" title="1">{
        r := hosts.recordIndex[recordID(rQuery.ID)]
        if r == nil </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying properties
        <span class="cov8" title="1">if rQuery.Zone != 0 &amp;&amp; rQuery.Zone != r.Zone </span><span class="cov8" title="1">{
            return nil
        }</span>
        <span class="cov8" title="1">if rQuery.Address != "" &amp;&amp; rQuery.Address != r.Address </span><span class="cov8" title="1">{
            return nil
        }</span>
        <span class="cov8" title="1">if len(rQuery.Names) &gt; 0 </span><span class="cov8" title="1">{
            // a valid record has all names (or more) that are found in r.Names
            valid := true
            for _, n := range rQuery.Names </span><span class="cov8" title="1">{
                found := false
                for _, name := range r.Names </span><span class="cov8" title="1">{
                    if n == name </span><span class="cov8" title="1">{
                        found = true
                        break</span>
                    }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                    valid = false
                    break</span>
                }
            }
            <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{
                return nil
            }</span>
        }

        <span class="cov8" title="1">return r</span>
    }

    <span class="cov8" title="1">if len(rQuery.Names) &gt; 0 </span><span class="cov8" title="1">{
        rs := hosts.recordNames[rQuery.Names[0]]
        if len(rs) == 0 </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying names
        <span class="cov8" title="1">if len(rQuery.Names) &gt; 0 </span><span class="cov8" title="1">{
            rsReduced := make([]*Record, 0)
            for _, candidate := range rs </span><span class="cov8" title="1">{
                // a valid candidate has all names (or more) that are found in rQuery.Names
                valid := true
                for _, n := range rQuery.Names </span><span class="cov8" title="1">{
                    found := false
                    for _, name := range candidate.Names </span><span class="cov8" title="1">{
                        if n == name </span><span class="cov8" title="1">{
                            found = true
                            break</span>
                        }
                    }
                    <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        valid = false
                        break</span>
                    }
                }
                <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                    rsReduced = append(rsReduced, candidate)
                }</span>
            }
            <span class="cov8" title="1">rs = rsReduced

            if len(rs) == 0 </span><span class="cov8" title="1">{
                return nil
            }</span>
        }

        // check other identifying properties
        <span class="cov8" title="1">if rQuery.Address != "" </span><span class="cov8" title="1">{
            rsReduced := make([]*Record, 0)
            for _, candidate := range rs </span><span class="cov8" title="1">{
                // a valid candidate has an address equal to rQuery.Address
                if candidate.Address == rQuery.Address </span><span class="cov8" title="1">{
                    rsReduced = append(rsReduced, candidate)
                }</span>
            }
            <span class="cov8" title="1">rs = rsReduced

            if len(rs) == 0 </span><span class="cov8" title="1">{
                return nil
            }</span>
        }
        <span class="cov8" title="1">if rQuery.Zone != 0 </span><span class="cov8" title="1">{
            rsReduced := make([]*Record, 0)
            for _, candidate := range rs </span><span class="cov8" title="1">{
                // a valid candidate has a zone equal to rQuery.Zone
                if candidate.Zone == rQuery.Zone </span><span class="cov8" title="1">{
                    rsReduced = append(rsReduced, candidate)
                }</span>
            }
            <span class="cov8" title="1">rs = rsReduced

            if len(rs) == 0 </span><span class="cov8" title="1">{
                return nil
            }</span>
        }

        <span class="cov8" title="1">if len(rs) != 1 </span><span class="cov8" title="1">{
            // if more than 1 valid record, 'get' cannot decide which one to return
            return nil
        }</span>

        <span class="cov8" title="1">return rs[0]</span>
    }

    <span class="cov8" title="1">if rQuery.Address != "" </span><span class="cov8" title="1">{
        rs := hosts.recordAddresses[rQuery.Address]
        if len(rs) == 0 </span><span class="cov8" title="1">{
            return nil
        }</span>

        // check other identifying properties
        <span class="cov8" title="1">if rQuery.Zone != 0 </span><span class="cov8" title="1">{
            rsReduced := make([]*Record, 0)
            for _, candidate := range rs </span><span class="cov8" title="1">{
                // a valid candidate has a zone equal to rQuery.Zone
                if candidate.Zone == rQuery.Zone </span><span class="cov8" title="1">{
                    rsReduced = append(rsReduced, candidate)
                }</span>
            }
            <span class="cov8" title="1">rs = rsReduced

            if len(rs) == 0 </span><span class="cov8" title="1">{
                return nil
            }</span>
        }

        <span class="cov8" title="1">if len(rs) != 1 </span><span class="cov8" title="1">{
            // if more than 1 valid record, 'get' cannot decide which one to return
            return nil
        }</span>

        <span class="cov8" title="1">return rs[0]</span>
    }

    <span class="cov8" title="1">if rQuery.Zone != 0 </span><span class="cov8" title="1">{
        rs := hosts.recordZones[zoneID(rQuery.Zone)]

        if len(rs) != 1 </span><span class="cov8" title="1">{
            // if more than 1 valid record, 'get' cannot decide which one to return
            return nil
        }</span>

        <span class="cov8" title="1">return rs[0]</span>
    }

    <span class="cov8" title="1">return nil</span>
}

func addRecord(r *Record) <span class="cov8" title="1">{
    if r.id != 0 </span><span class="cov8" title="1">{
        // record already indexed
        return
    }</span>

    <span class="cov8" title="1">id := hosts.newRecordID()
    zone := zoneID(r.Zone)
    address := r.Address
    names := r.Names

    hosts.recordIndex[id] = r
    hosts.recordZones[zone] = append(hosts.recordZones[zone], r)
    hosts.recordAddresses[address] = append(hosts.recordAddresses[address], r)
    for _, n := range names </span><span class="cov8" title="1">{
        hosts.recordNames[n] = append(hosts.recordNames[n], r)
    }</span>

    <span class="cov8" title="1">r.ID = int(id)
    r.id = id

    return</span>
}

func removeRecord(r *Record) <span class="cov8" title="1">{
    if r.id == 0 </span><span class="cov8" title="1">{
        // file not indexed yet/anymore
        return
    }</span>

    <span class="cov8" title="1">id := r.id
    zone := zoneID(r.Zone)
    address := r.Address
    names := r.Names

    delete(hosts.recordIndex, id)
    hosts.recordZones[zone] = deleteFromSliceOfRecords(hosts.recordZones[zone], r)
    hosts.recordAddresses[address] = deleteFromSliceOfRecords(hosts.recordAddresses[address], r)
    for _, n := range names </span><span class="cov8" title="1">{
       hosts.recordNames[n] = deleteFromSliceOfRecords(hosts.recordNames[n], r)
    }</span>

    <span class="cov8" title="1">r.ID = 0
    r.id = recordID(0)

    return</span>
}

func deleteFromSliceOfRecords(rs []*Record, r *Record) []*Record <span class="cov8" title="1">{
    if len(rs) == 0 </span><span class="cov8" title="1">{
        return []*Record(nil)   // always return a copy
    }</span>

    <span class="cov8" title="1">newRecords := make([]*Record, len(rs) - 1)
    decr := 0
    for i, record := range rs </span><span class="cov8" title="1">{
        if record.id == r.id </span><span class="cov8" title="1">{
            decr = 1
        }</span> else<span class="cov8" title="1"> {
            newRecords[i-decr] = rs[i]
        }</span>
    }

    <span class="cov8" title="1">return newRecords</span>
}

// -----------------------------------------------------------------------------
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
    "errors"
)

// -----------------------------------------------------------------------------

type Record struct {
    // readOnly
    ID      int        // indexed   // read-write in a rQuery
    // read-writeOnce
    Zone    int        // indexed   // read-write in a rQuery
    // read-writeMany
    Address string     // indexed
    Names   []string   // indexed
    Comment string
    Notes   string
    // readOnly
    Managed bool
    // readOnly        //-computed
//    FQDN       string
//    Domain     string
//    RootDomain string
    // private
    id      recordID
}

func LookupRecord(rQuery *Record) (r *Record) <span class="cov8" title="1">{
    rPrivate := lookupRecord(rQuery)
    if rPrivate == nil </span><span class="cov8" title="1">{
        return nil
    }</span>

    // make a copy without the private fields
    <span class="cov8" title="1">r = new(Record)
    r.ID      = rPrivate.ID
    r.Zone    = rPrivate.Zone
    r.Address = rPrivate.Address
    r.Names   = make([]string, len(rPrivate.Names))
    copy(r.Names, rPrivate.Names)
    r.Comment = rPrivate.Comment
    r.Notes   = rPrivate.Notes
    r.Managed   = rPrivate.Managed
    // ignore computed fields

    return r</span>
}

func CreateRecord(rValues *Record) error <span class="cov8" title="1">{
    if rValues.Zone == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateRecord(rValues)] missing 'rValues.Zone'")
    }</span>
    <span class="cov8" title="1">if rValues.Address == "" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateRecord(rValues)] missing 'rValues.Address'")
    }</span>
    <span class="cov8" title="1">if len(rValues.Names) == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateRecord(rValues)] missing 'rValues.Names'")
    }</span>

    // lookup all indexed fields except ID
    <span class="cov8" title="1">rQuery := new(Record)
    rQuery.Zone    = rValues.Zone
    rQuery.Address = rValues.Address
    rQuery.Names   = make([]string, len(rValues.Names))
    copy(rQuery.Names, rValues.Names)

    rPrivate := lookupRecord(rQuery)
    if rPrivate != nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateRecord(rValues)] another record with similar properties already exists")
    }</span>

    // take ownership
    <span class="cov8" title="1">rValues.Managed = true

    return createRecord(rValues)</span>   // rValues.ID will be ignored
}

func (r *Record) Read() (record *Record, err error) <span class="cov0" title="0">{
    if r.ID == 0 </span><span class="cov0" title="0">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/r.Read()] missing 'r.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov0" title="0">rQuery := new(Record)
    rQuery.ID = r.ID

    rPrivate := lookupRecord(rQuery)
    if rPrivate == nil </span><span class="cov0" title="0">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/r.Read()] record not found")
    }</span>

    <span class="cov0" title="0">rPrivate, err = readRecord(rPrivate)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    // make a copy without the private fields
    <span class="cov0" title="0">record = new(Record)
    record.ID      = rPrivate.ID
    record.Zone    = rPrivate.Zone
    record.Address = rPrivate.Address
    record.Names   = make([]string, len(rPrivate.Names))
    copy(record.Names, rPrivate.Names)
    record.Comment = rPrivate.Comment
    record.Notes   = rPrivate.Notes
    record.Managed = rPrivate.Managed
    // no computed fields

    return record, nil</span>
}

func (r *Record) Update(rValues *Record) error <span class="cov0" title="0">{
    if r.ID == 0 </span><span class="cov0" title="0">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Update(rValues)] missing 'r.ID'")
    }</span>
    <span class="cov0" title="0">if rValues.Address == "" </span><span class="cov0" title="0">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Update(rValues)] missing 'rValues.Address'")
    }</span>
    <span class="cov0" title="0">if len(rValues.Names) == 0 </span><span class="cov0" title="0">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Update(rValues)] missing 'rValues.Names'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov0" title="0">rQuery := new(Record)
    rQuery.ID = r.ID

    rPrivate := lookupRecord(rQuery)
    if rPrivate == nil </span><span class="cov0" title="0">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Update(rValues)] record not found")
    }</span>

    <span class="cov0" title="0">return updateRecord(rPrivate, rValues)</span>   // rValues.ID and rValues.Zone will be ignored
}

func (r *Record) Delete() error <span class="cov8" title="1">{
    if r.ID == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Delete(rValues)] missing 'r.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">rQuery := new(Record)
    rQuery.ID = r.ID

    rPrivate := lookupRecord(rQuery)
    if rPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/r.Delete()] record not found")
    }</span>

    <span class="cov8" title="1">return deleteRecord(rPrivate)</span>
}

// -----------------------------------------------------------------------------
//
// naming guidelines:
//
// - (r *Record)         the result of the public CreateRecord method and LookupRecord method
//                           this doesn't include the computed fields (always use a read method to get the computed fields)
//                           this doesn't include private fields
//
//                       the result of the private createRecord method and lookupRecord method (hosts.go)
//                           this doesn't include the computed fields (always use a read method to get the computed fields)
//
//                       the anchor for the public Read/Update/Delete methods
//                           this must include the 'ID' field
//
//                       the input for the private readRecord/updateRecord/deleteRecord methods
//                           this must include the private 'id' field
//
// - (rQuery *Record)    the input for the public LookupRecord method
//                       the input for the private lookupRecord method (hosts.go)
//                           this should include at least one of the indexed fields
//
//   (rValues *Record)   the input for the public CreateRecord/Update methods
//                       the input for the private createRecord/updateRecord methods
//                           for a create method, this must include *all* writeMany and writeOnce fields
//                           for an update method, this must include *all* writeMany fields
//
// - (record *Record)    the result of the public Read method
//                       the result of the private readRecord method
//                           this does include all computed fields
//
// -----------------------------------------------------------------------------

func createRecord(rValues *Record) error <span class="cov8" title="1">{
    // create record
    r := new(Record)
    r.Zone    = rValues.Zone
    r.Address = rValues.Address
    r.Names   = make([]string, len(rValues.Names))
    copy(r.Names, rValues.Names)
    r.Comment = rValues.Comment
    r.Notes   = rValues.Notes
    r.Managed = rValues.Managed

    addRecord(r)   // adds r.ID and r.id

//    managed := rValues.Managed   // managed when called from CreateRecord, unmanaged when called from goScanLines (zone.go)

    return nil
}</span>

func readRecord(r *Record) (record *Record, err error) <span class="cov0" title="0">{
    return r, nil
}</span>

func updateRecord(r *Record, rValues *Record) error <span class="cov0" title="0">{
    return nil
}</span>

func deleteRecord(r *Record) error <span class="cov8" title="1">{
    // remove and zero file object
    r.Zone    = 0
    r.Address = ""
    r.Names   = make([]string, 0)
    r.Comment = ""
    r.Notes   = ""
    r.Managed = false

    removeRecord(r)   // zeroes r.ID and r.id

    return nil
}</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
    "errors"
)

// -----------------------------------------------------------------------------

type Zone struct {
    // readOnly
    ID       int      // indexed   // read-write in a zQuery
    // read-writeOnce
    File     int      // indexed   // read-write in a zQuery
    Name     string   // indexed   // read-write in a zQuery
    // read-writeMany
    Notes    string
    // private
    id       zoneID
    lines    []string
    checksum string
}

func LookupZone(zQuery *Zone) (z *Zone) <span class="cov8" title="1">{
    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov8" title="1">{
        return nil
    }</span>

    // make a copy without the private fields
    <span class="cov8" title="1">z = new(Zone)
    z.ID    = zPrivate.ID
    z.File  = zPrivate.File
    z.Name  = zPrivate.Name
    z.Notes = zPrivate.Notes
    // ignore computed fields

    return z</span>
}

func CreateZone(zValues *Zone) error <span class="cov8" title="1">{
    if zValues.File == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateZone(zValues)] missing 'zValues.File'")
    }</span>
    <span class="cov8" title="1">if zValues.Name == "" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateZone(zValues)] missing 'zValues.Name'")
    }</span>
    <span class="cov8" title="1">if zValues.Name == "external" </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateZone(zValues)] illegal value \"external\" specified for 'zValues.Name'")
    }</span>

    // lookup all indexed fields except ID
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.File = zValues.File
    zQuery.Name = zValues.Name

    zPrivate := lookupZone(zQuery)
    if zPrivate != nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/CreateZone(zValues)] another zone with similar properties already exists")
    }</span>

    <span class="cov8" title="1">return createZone(zValues)</span>   // zValues.ID will be ignored
}

func (z *Zone) Read() (zone *Zone, err error) <span class="cov0" title="0">{
    if z.ID == 0 </span><span class="cov0" title="0">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/z.Read()] missing 'z.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov0" title="0">zQuery := new(Zone)
    zQuery.ID = z.ID

    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov0" title="0">{
        return nil, errors.New("[ERROR][terraform-provider-hosts/api/z.Read()] zone not found")
    }</span>

    <span class="cov0" title="0">zPrivate, err = readZone(zPrivate)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    // make a copy without the private fields
    <span class="cov0" title="0">zone = new(Zone)
    zone.ID      = zPrivate.ID
    zone.File    = zPrivate.File
    zone.Name    = zPrivate.Name
    zone.Notes   = zPrivate.Notes
    // no computed fields

    return zone, nil</span>
}

func (z *Zone) Update(zValues *Zone) error <span class="cov0" title="0">{
    if z.ID == 0 </span><span class="cov0" title="0">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Update(zValues)] missing 'z.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov0" title="0">zQuery := new(Zone)
    zQuery.ID = z.ID

    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov0" title="0">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Update(zValues)] zone not found")
    }</span>

    <span class="cov0" title="0">return updateZone(zPrivate, zValues)</span>   // zValues.ID, zValues.Name and zValues.File will be ignored
}

func (z *Zone) Delete() error <span class="cov8" title="1">{
    if z.ID == 0 </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Delete(zValues)] missing 'z.ID'")
    }</span>

    // lookup the ID field only, ignore any other fields
    <span class="cov8" title="1">zQuery := new(Zone)
    zQuery.ID = z.ID

    zPrivate := lookupZone(zQuery)
    if zPrivate == nil </span><span class="cov8" title="1">{
        return errors.New("[ERROR][terraform-provider-hosts/api/z.Delete()] zone not found")
    }</span>

    <span class="cov8" title="1">return deleteZone(zPrivate)</span>
}

// -----------------------------------------------------------------------------
//
// naming guidelines:
//
// - (z *Zone)         the result of the public CreateFile method and LookupFile method
//                         this doesn't include the computed fields (always use a read method to get the computed fields)
//                         this doesn't include the private fields
//
//                     the result of the private createFile method and lookupFile method (hosts.go)
//                         this doesn't include the computed fields (always use a read method to get the computed fields)
//
//                     the anchor for the public Read/Update/Delete methods
//                         this must include the 'ID' field
//
//                     the input for the private read/update/delete methods
//                         this must include the private 'id' field
//
// - (zQuery *Zone)    the input for the public LookupFile method
//                     the input for the private lookupFile method (hosts.go)
//                         this should include at least one of the indexed fields
//
//   (zValues *Zone)   the input for the public CreateFile/Update methods
//                     the input for the private createFile/update methods
//                         for a create method, this must include *all* writeMany and writeOnce fields
//                         for an update method, this must include *all* writeMany fields
//
// - (zone *Zone)      the result of the public Read method
//                     the result of the private read method
//                         this does include all computed fields
//
// -----------------------------------------------------------------------------

func createZone(zValues *Zone) error <span class="cov8" title="1">{
    // create zone
    z := new(Zone)
    z.File    = zValues.File
    z.Name    = zValues.Name
    z.Notes   = zValues.Notes

    addZone(z)   // adds z.ID and z.id

    return nil
}</span>

func readZone(z *Zone) (zone *Zone, err error) <span class="cov0" title="0">{
    return z, nil
}</span>

func updateZone(z *Zone, zValues *Zone) error <span class="cov0" title="0">{
    return nil
}</span>

func deleteZone(z *Zone) error <span class="cov8" title="1">{
    // remove and zero file object
    z.File    = 0
    z.Name    = ""
    z.Notes   = ""

    removeZone(z)   // zeroes z.ID and z.id

    return nil
}</span>

// -----------------------------------------------------------------------------

func goScanLines(z *Zone, lines &lt;-chan string) chan error <span class="cov8" title="1">{
    cerr := make(chan error)

    go func() </span><span class="cov8" title="1">{
        defer close(cerr)
        
        for _ = range lines </span>{<span class="cov8" title="1">
//            ...
        }</span>

        <span class="cov8" title="1">cerr &lt;- nil
        return</span>
    }()

    <span class="cov8" title="1">return cerr</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
